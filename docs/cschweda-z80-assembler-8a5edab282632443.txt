Directory structure:
‚îî‚îÄ‚îÄ cschweda-z80-assembler/
    ‚îú‚îÄ‚îÄ index.html
    ‚îú‚îÄ‚îÄ JSDOC_GUIDE.md
    ‚îú‚îÄ‚îÄ JSDOC_STATUS.md
    ‚îú‚îÄ‚îÄ LICENSE
    ‚îú‚îÄ‚îÄ netlify.toml
    ‚îú‚îÄ‚îÄ package.json
    ‚îú‚îÄ‚îÄ vite.config.js
    ‚îú‚îÄ‚îÄ .nvmrc
    ‚îú‚îÄ‚îÄ docs/
    ‚îÇ   ‚îî‚îÄ‚îÄ images/
    ‚îÇ       ‚îî‚îÄ‚îÄ README.md
    ‚îú‚îÄ‚îÄ roms/
    ‚îÇ   ‚îú‚îÄ‚îÄ model3.rom
    ‚îÇ   ‚îî‚îÄ‚îÄ model3.rom.ihex
    ‚îú‚îÄ‚îÄ src/
    ‚îÇ   ‚îú‚îÄ‚îÄ assembler.js
    ‚îÇ   ‚îú‚îÄ‚îÄ codegen.js
    ‚îÇ   ‚îú‚îÄ‚îÄ constants.js
    ‚îÇ   ‚îú‚îÄ‚îÄ evaluator.js
    ‚îÇ   ‚îú‚îÄ‚îÄ lexer.js
    ‚îÇ   ‚îú‚îÄ‚îÄ main.js
    ‚îÇ   ‚îú‚îÄ‚îÄ opcodes.js
    ‚îÇ   ‚îú‚îÄ‚îÄ parser.js
    ‚îÇ   ‚îú‚îÄ‚îÄ examples/
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ programs.js
    ‚îÇ   ‚îú‚îÄ‚îÄ tests/
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ test-suite.js
    ‚îÇ   ‚îú‚îÄ‚îÄ ui/
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ examples.js
    ‚îÇ   ‚îî‚îÄ‚îÄ utils/
    ‚îÇ       ‚îî‚îÄ‚îÄ formatter.js
    ‚îî‚îÄ‚îÄ styles/
        ‚îî‚îÄ‚îÄ main.css

================================================
FILE: index.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRS-80 Model III Z80 Assembler</title>
    <link rel="stylesheet" href="/styles/main.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>TRS-80 Model III Z80 Assembler</h1>
        </header>

        <div class="toolbar">
            <select id="example-select">
                <option value="">Select an example program...</option>
            </select>
            <button id="assemble-btn">Assemble</button>
            <div id="status" class="status status-info">Status: Ready</div>
        </div>

        <div class="main-content">
            <div class="panel source-panel">
                <h2>Source Code <span id="char-counter" class="char-counter"></span></h2>
                <textarea id="source-editor" placeholder="Enter Z80 assembly source code here..." maxlength="8000"></textarea>
            </div>

            <div class="panel output-panel">
                <h2>Memory Dump</h2>
                <pre id="output-dump"></pre>
            </div>
        </div>

        <div class="secondary-content">
            <div class="panel symbols-panel">
                <h2>Symbol Table</h2>
                <pre id="symbol-table"></pre>
            </div>

            <div class="panel errors-panel">
                <h2>Errors / Warnings</h2>
                <div class="errors-section">
                    <h3>Errors</h3>
                    <pre id="errors">No errors.</pre>
                </div>
                <div class="warnings-section">
                    <h3>Warnings</h3>
                    <pre id="warnings">No warnings.</pre>
                </div>
            </div>
        </div>
    </div>

    <script type="module" src="/src/main.js"></script>
</body>
</html>




================================================
FILE: JSDOC_GUIDE.md
================================================
# JSDoc Documentation Guide

This guide documents the JSDoc patterns and conventions used throughout the Z80 Assembler codebase.

## Documentation Progress: 50% Complete ‚úÖ

**Status**: 6 out of 12 JavaScript files fully documented (~1,200 lines of JSDoc)

### ‚úÖ Fully Documented Files (6/12)

**Core Infrastructure:**
- ‚úÖ `src/assembler.js` (232 lines) - Main assembler orchestrator with complete API
- ‚úÖ `src/constants.js` (236 lines) - All enumerations, registers, memory map
- ‚úÖ `src/evaluator.js` (261 lines) - Expression parser with grammar specification

**Utilities & UI:**
- ‚úÖ `src/utils/formatter.js` (221 lines) - All formatting functions with examples
- ‚úÖ `src/ui/examples.js` (105 lines) - Example program management API
- ‚úÖ `src/main.js` (186 lines) - UI initialization and event handling

### üîÑ Remaining Files to Document (6/12)

**Critical Core Modules** (High Priority):
- üîÑ `src/lexer.js` (261 lines) - Tokenizer
- üîÑ `src/parser.js` (922 lines) - Two-pass parser
- üîÑ `src/codegen.js` (307 lines) - Code generator
- üîÑ `src/opcodes.js` (547 lines) - Instruction encodings

**Support Files:**
- üîÑ `src/tests/test-suite.js` (215 lines) - Test suite
- üîÑ `src/examples/programs.js` (507 lines) - Example programs database

## JSDoc Patterns Used

### 1. File-Level Documentation

Every module starts with a `@fileoverview`:

```javascript
/**
 * @fileoverview Brief description of the module
 * 
 * Detailed explanation of what this module does,
 * its purpose, and how it fits into the larger system.
 * 
 * @module module/path
 * @requires ./dependency
 */
```

### 2. Type Definitions

Complex objects are defined using `@typedef`:

```javascript
/**
 * @typedef {Object} AssemblyResult
 * @property {boolean} success - Whether assembly succeeded
 * @property {Uint8Array} bytes - Generated machine code
 * @property {number} startAddress - Starting address
 * @property {Array<Error>} errors - Errors encountered
 * @property {Array<Warning>} warnings - Warnings generated
 * @property {Object<string, Symbol>} symbolTable - Symbol table
 */
```

### 3. Class Documentation

Classes include description, examples, and constructor docs:

```javascript
/**
 * Z80 Assembler class description
 * 
 * Detailed explanation of class purpose and usage.
 * 
 * @class
 * @example
 * const assembler = new Z80Assembler();
 * const result = assembler.assemble(source);
 */
export class Z80Assembler {
  /**
   * Creates a new instance
   * @param {Object} options - Configuration options
   */
  constructor(options) {
    // ...
  }
}
```

### 4. Function Documentation

Functions include full parameter and return documentation with examples:

```javascript
/**
 * Brief description of what the function does
 * 
 * Detailed explanation including:
 * - Algorithm used
 * - Side effects
 * - Error conditions
 * 
 * @param {string} source - Parameter description
 * @param {Object} options - Options object
 * @param {boolean} options.strict - Option description
 * @returns {ResultType} Description of return value
 * @throws {Error} When invalid input provided
 * 
 * @example
 * const result = functionName('input', { strict: true });
 * console.log(result);
 */
export function functionName(source, options) {
  // ...
}
```

### 5. Constant Documentation

Constants are documented with their purpose and possible values:

```javascript
/**
 * Token type enumeration
 * 
 * Defines all possible token types that the lexer can produce.
 * 
 * @enum {string}
 * @readonly
 */
export const TOKEN = {
  /** Identifier (potential label) */
  LABEL: 'LABEL',
  
  /** Z80 instruction mnemonic */
  MNEMONIC: 'MNEMONIC'
};
```

### 6. Complex Object Properties

Objects with multiple properties are fully documented:

```javascript
/**
 * TRS-80 Model III memory map
 * 
 * Defines the complete memory layout.
 * 
 * @type {Object}
 * @readonly
 * 
 * @property {number} ROM_START - ROM begins at $0000
 * @property {number} ROM_END - ROM ends at $37FF (14KB)
 * @property {number} VIDEO_START - Video RAM at $3C00
 * 
 * @example
 * .ORG $4200
 * LD HL, MEMORY.VIDEO_START
 */
export const MEMORY = {
  ROM_START: 0x0000,
  // ...
};
```

## Template for Remaining Files

### Lexer Template

```javascript
/**
 * @fileoverview Z80 Assembly Lexer - Tokenizes assembly source code
 * 
 * The lexer converts raw assembly source text into a stream of tokens
 * that can be consumed by the parser. Handles all Z80 syntax including
 * labels, mnemonics, registers, numbers (hex/binary/decimal), strings,
 * directives, operators, and comments.
 * 
 * @module lexer
 * @requires ./constants
 */

/**
 * Lexer class - Tokenizes Z80 assembly source code
 * 
 * Performs lexical analysis on assembly source, breaking it into
 * discrete tokens. Handles multiple number formats, string literals,
 * comments, and maintains line/column tracking for error reporting.
 * 
 * @class
 * @example
 * const lexer = new Lexer('LD A, 5\nHALT');
 * const tokens = lexer.tokenize();
 */
export class Lexer {
  /**
   * Creates a new Lexer instance
   * @param {string} source - Assembly source code to tokenize
   */
  constructor(source) {
    // ...
  }

  /**
   * Tokenizes the entire source into an array of tokens
   * 
   * Main entry point for lexical analysis. Scans through source
   * character by character, identifying and creating tokens.
   * 
   * @returns {Array<Token>} Array of token objects
   * @throws {Error} On unexpected characters or syntax errors
   * 
   * @example
   * const tokens = lexer.tokenize();
   * tokens.forEach(t => console.log(t.type, t.value));
   */
  tokenize() {
    // ...
  }
}
```

### Parser Template

```javascript
/**
 * @fileoverview Z80 Assembly Parser - Two-pass parsing with symbol resolution
 * 
 * Implements a two-pass parser that builds a symbol table (pass 1)
 * and generates instruction objects with resolved operands (pass 2).
 * Handles forward references, expressions, and all Z80 addressing modes.
 * 
 * @module parser
 * @requires ./constants
 * @requires ./evaluator
 */

/**
 * Parser class - Converts tokens into instruction objects
 * 
 * Two-pass assembly:
 * - Pass 1: Builds symbol table, calculates instruction sizes
 * - Pass 2: Generates instruction objects with resolved operands
 * 
 * @class
 */
export class Parser {
  /**
   * Parse tokens into instructions
   * 
   * Main entry point. Performs both passes and returns
   * the final parsed result with instructions and symbol table.
   * 
   * @returns {Object} Parse result with instructions and symbols
   * @returns {Array} return.instructions - Array of instruction objects
   * @returns {Object} return.symbolTable - Symbol table with addresses
   * @returns {Array} return.errors - Parse errors
   * @returns {Array} return.warnings - Parse warnings
   */
  parse() {
    // ...
  }
}
```

## Benefits of JSDoc Documentation

1. **IDE Support**: Enables autocomplete, parameter hints, and type checking
2. **Maintainability**: Makes code easier to understand and modify
3. **Documentation Generation**: Can generate HTML docs with JSDoc tool
4. **Type Safety**: Provides TypeScript-like type checking in JavaScript
5. **Onboarding**: Helps new developers understand the codebase
6. **API Clarity**: Clear contracts for function parameters and returns

## Generating HTML Documentation

To generate HTML documentation from JSDoc comments:

```bash
# Install JSDoc
npm install -g jsdoc

# Generate documentation
jsdoc src -r -d docs

# Open in browser
open docs/index.html
```

## Best Practices

1. **Be Detailed**: More documentation is better than less
2. **Include Examples**: Show actual usage patterns
3. **Document Types**: Use @param, @returns, @typedef
4. **Explain Why**: Not just what, but why it works that way
5. **Keep Updated**: Update docs when code changes
6. **Use @private**: Mark internal functions
7. **Link Related**: Use @see to cross-reference
8. **Document Errors**: Use @throws for error conditions

## VSCode Settings

For best JSDoc experience in VSCode, add to `.vscode/settings.json`:

```json
{
  "javascript.suggest.completeJSDocs": true,
  "javascript.suggest.jsdoc.generateReturns": true,
  "editor.quickSuggestions": {
    "other": true,
    "comments": true,
    "strings": true
  }
}
```

This enables automatic JSDoc generation and enhanced IntelliSense.




================================================
FILE: JSDOC_STATUS.md
================================================
# JSDoc Documentation Status

## Completed Files ‚úÖ (6/12 - 50%)

### Core Infrastructure
- ‚úÖ **src/assembler.js** (232 lines)
  - Complete file overview with module documentation
  - Type definitions: AssemblyResult, Symbol, AssemblyError, AssemblyWarning
  - All public and private methods documented
  - Examples included

- ‚úÖ **src/constants.js** (236 lines)
  - All enumerations documented
  - Z80 register encodings with bit patterns
  - TRS-80 Model III memory map explained
  - Complete inline documentation

- ‚úÖ **src/evaluator.js** (261 lines)
  - Grammar specification documented
  - Recursive descent parser explained
  - All precedence levels documented
  - Expression examples included

### Utilities & UI
- ‚úÖ **src/utils/formatter.js** (221 lines)
  - All formatting functions documented
  - TRS-80 DEBUG format explained
  - Examples for each function

- ‚úÖ **src/ui/examples.js** (105 lines)
  - Type definition for ExampleProgram
  - Complete API documentation
  - Usage examples

- ‚úÖ **src/main.js** (181 lines)
  - UI initialization documented
  - Event handlers explained
  - Keyboard shortcuts documented

## Remaining Files üîÑ (6/12 - 50%)

### Critical Core Modules
1. **src/lexer.js** (261 lines) ‚ö†Ô∏è Priority
   - Tokenization logic
   - Number format parsing
   - Character scanning

2. **src/parser.js** (922 lines) ‚ö†Ô∏è Priority  
   - Two-pass assembly
   - Symbol table building
   - Instruction parsing

3. **src/codegen.js** (307 lines) ‚ö†Ô∏è Priority
   - Bytecode generation
   - Label resolution
   - Instruction encoding

4. **src/opcodes.js** (547 lines)
   - Instruction encoding tables
   - Opcode patterns
   - Z80 instruction set

### Support Files
5. **src/tests/test-suite.js** (215 lines)
   - Test framework
   - Validation logic
   - Test reporting

6. **src/examples/programs.js** (507 lines)
   - Example program database
   - Expected outputs
   - Test cases

## Documentation Quality Standards

All completed files include:
- ‚úÖ File-level @fileoverview with module purpose
- ‚úÖ Type definitions using @typedef
- ‚úÖ Class documentation with @class and examples
- ‚úÖ Method documentation with @param, @returns, @throws
- ‚úÖ Private methods marked with @private
- ‚úÖ Real-world usage examples
- ‚úÖ Detailed explanations of algorithms
- ‚úÖ Error conditions documented

## Next Steps

The remaining files follow established patterns:

### For Lexer/Parser/Codegen:
- Document public API methods fully
- Explain algorithms (tokenization, two-pass, encoding)
- Add examples for each major function
- Document error conditions

### For Opcodes:
- Document encoding functions
- Explain opcode patterns
- Link to Z80 documentation

### For Tests/Examples:
- Document test framework
- Explain validation logic
- Document example structure

## Estimated Lines of Documentation

- Completed: ~1,200 lines of JSDoc
- Remaining: ~1,500 lines needed
- Total: ~2,700 lines of documentation

This provides comprehensive coverage while maintaining readability.

## Tools & Commands

Generate HTML documentation:
\`\`\`bash
npm install -g jsdoc
jsdoc src -r -d docs
\`\`\`

VSCode IntelliSense:
- Autocomplete enabled for all documented modules
- Parameter hints available
- Type checking active

## Benefits Achieved

‚úÖ IDE autocomplete and IntelliSense
‚úÖ Better code maintainability  
‚úÖ Clear API contracts
‚úÖ Onboarding documentation
‚úÖ Type safety in JavaScript
‚úÖ Professional codebase standards



================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) 2025 Christopher Schweda

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.




================================================
FILE: netlify.toml
================================================
[build]
  # Build command to run
  command = "yarn build"
  # Directory containing the built static files (output from vite build)
  publish = "dist"

[build.environment]
  NODE_VERSION = "22.21.1"
  YARN_VERSION = "1.22.22"

# SPA routing - redirect all routes to index.html
[[redirects]]
  from = "/*"
  to = "/index.html"
  status = 200

# Headers for static assets
[[headers]]
  for = "/assets/*"
  [headers.values]
    Cache-Control = "public, max-age=31536000, immutable"

# Headers for ROM files
[[headers]]
  for = "/roms/*"
  [headers.values]
    Cache-Control = "public, max-age=31536000, immutable"
    Content-Type = "application/octet-stream"

# Headers for HTML
[[headers]]
  for = "/*.html"
  [headers.values]
    Cache-Control = "public, max-age=0, must-revalidate"
    X-Frame-Options = "DENY"
    X-Content-Type-Options = "nosniff"




================================================
FILE: package.json
================================================
{
    "name": "z80-assembler",
    "version": "1.0.0",
    "description": "Z80 Assembler (compiler) for TRS-80 Model III - converts assembly source code to bytecode",
    "type": "module",
    "author": "Christopher Schweda",
    "license": "MIT",
    "scripts": {
        "dev": "vite",
        "build": "vite build",
        "preview": "vite preview",
        "test": "node src/tests/test-suite.js"
    },
    "devDependencies": {
        "vite": "^5.0.0"
    },
    "engines": {
        "node": ">=22.21.1",
        "yarn": "1.22.22"
    }
}


================================================
FILE: vite.config.js
================================================
import { defineConfig } from 'vite';
import { copyFileSync, mkdirSync, readdirSync, statSync, existsSync } from 'fs';
import { join } from 'path';

// Plugin to copy roms directory to dist and show build completion message
function copyRomsPlugin() {
  return {
    name: 'copy-roms',
    closeBundle() {
      const srcDir = 'roms';
      const destDir = 'dist/roms';
      
      try {
        if (existsSync(srcDir) && statSync(srcDir).isDirectory()) {
          mkdirSync(destDir, { recursive: true });
          const files = readdirSync(srcDir);
          files.forEach(file => {
            const srcPath = join(srcDir, file);
            const destPath = join(destDir, file);
            if (statSync(srcPath).isFile()) {
              copyFileSync(srcPath, destPath);
            }
          });
          console.log(`‚úì Copied ${files.length} ROM file(s) to dist/roms`);
        }
      } catch (error) {
        console.warn('Warning: Could not copy roms directory:', error.message);
      }
      
      // Show build completion message
      console.log('\n' + '='.repeat(60));
      console.log('‚úì Build completed successfully!');
      console.log('='.repeat(60));
      console.log('üìÅ Output directory: dist/');
      console.log('üìÑ Static HTML files ready for deployment');
      console.log('üöÄ Preview options:');
      console.log('   ‚Ä¢ yarn preview');
      console.log('   ‚Ä¢ serve dist');
      console.log('   ‚Ä¢ npx http-server dist');
      console.log('='.repeat(60) + '\n');
    }
  };
}

export default defineConfig({
  build: {
    outDir: 'dist',
    assetsDir: 'assets',
    sourcemap: false
  },
  server: {
    port: 3000,
    open: true
  },
  plugins: [copyRomsPlugin()]
});




================================================
FILE: .nvmrc
================================================
22.21.1




================================================
FILE: docs/images/README.md
================================================
# Screenshot Instructions

## Required Screenshot

Please add a screenshot file named `screenshot.png` showing:

1. **Source Code Panel** (left side):
   - An example Z80 assembly program (e.g., "Fill Screen" or "Add 2+2")
   - The source code should be visible and readable

2. **Memory Dump Panel** (right side):
   - The generated bytecode in TRS-80 DEBUG-style format
   - Showing addresses and hex values

3. **Symbol Table Panel** (bottom left):
   - Labels and their addresses
   - Constants and their values

4. **Errors/Warnings Panel** (bottom right):
   - Should show "No errors" and "No warnings" for a successful assembly

## Recommended Screenshot

- **Resolution**: 1920x1080 or higher
- **Format**: PNG
- **Content**: Show a complete, successful assembly with all panels visible
- **Example Program**: Use "Fill Screen with Solid Blocks" or "Add 2+2" for clarity

## How to Take the Screenshot

1. Run `yarn dev` to start the development server
2. Load an example program (e.g., "Fill Screen with Solid Blocks")
3. Click "Assemble" or press Ctrl+Enter
4. Take a full-screen or window screenshot
5. Save as `screenshot.png` in this directory (`docs/images/`)




================================================
FILE: roms/model3.rom
================================================
[Binary file]


================================================
FILE: roms/model3.rom.ihex
================================================
:10000000F3AFC31530C30040C30040E1E9C3123071
:10001000C30340C50601182EC30640C506021826B4
:10002000C30940C50604181EC30C4011154018E34F
:10003000C30F40111D4018E3C3124011254018DBC7
:10004000C3D905C90000C37406CD2B00B7C018F989
:1000500011E54118BE11ED4118C111F54118BC0060
:10006000C3FB0120FBC9C33930C35204111D421820
:10007000AA00C3CC0611804021F718012700EDB07B
:1000800021E542363A237023362C2322A740112D36
:1000900001061C21524136C3237323722310F70635
:1000A0001536C923232310F921E8437031F842CDD6
:1000B0008F1B000000210501CDA728CDB31B38F50B
:1000C000D7B72012214C44237CB5281B7E472F77BD
:1000D000BE7028F31811CD5A1EB7C29719EB2B3EEC
:1000E0008F4677BE7020CE2B111445DFDA7A1911B6
:1000F000CEFF22B1401922A040CD4D1B211101C3DA
:10010000EB37C3191A4D656D6F72792053697A65A3
:1001100000526164696F20536861636B204D6F64A6
:10012000656C204949492042617369630D1E2CC3E7
:10013000A219D7AF013E80013E01F5CF28CD1C2B7F
:10014000FE80D24A1EF5CF2CCD1C2BFE30D24A1E8B
:1001500016FF14D60330FBC6034FF1875F06027A01
:100160001F577B1F5F10F8798F3C47AF378F10FD0B
:100170004F7AF63C571AB7FA7C013E8047F1B778C0
:10018000281012FA8F01792F4F1AA112CF29C9B165
:1001900018F9A1C6FF9FE5CD8D09E118EFD7E53A23
:1001A0009940B72006CD5803B72811F5AF329940D2
:1001B0003CCD5728F12AD44077C38428212819221E
:1001C00021413E0332AF40E1C93E1CCD3A033E1F00
:1001D000C33A03ED5F32AB40C921003C7EFE80385C
:1001E000023E2ECD3B0023CB7420297DE63F20EC40
:1001F000CD140218E710FEC9C30C307F0B78B12074
:10020000FAC9286329202738302054616E64790D9B
:100210001E3DAFC93E0DCD3B00AFC97E23FE03C8D6
:10022000CD3300FE0D20F4C9E3C32A3018E4FBC32C
:10023000191A3F3CC9D5C5E52A0E42E3C9E521009C
:100240003018E5F3CD0F30E521063018DBE52A0C38
:1002500042E3C9E33A1142B72803232323E3C9C188
:10026000C9CD640218E73C3C181F1C1F1E1F1E1F2F
:100270001F1E1F1E1F00001D1E4469736B657474D2
:10028000653F03F2C38702F3CD0F3018B03A403810
:10029000E604C9C3430218AB3A1042CBC73210423E
:1002A000C93A1042CB8718F5C9CD140322DF40CDDF
:1002B000F801CDE241318842CDFE203E2ACD2A030D
:1002C000CDB31BDACC06D7CA9719FE2F284FCD9392
:1002D00002CD3502FE5520F906067EB72809CD3538
:1002E00002BE2320EC10F3CD2C02CD3502FE78287F
:1002F000B8FE3C20F5CD350247CD1403854FCD35F2
:10030000027723814F10F7CD3502B928DA3E433208
:100310003E3C18D6CD35026FCD350267C9EB2ADFDA
:1003200040EBD7C45A1E208AEBE9C54FCDC1413AF4
:100330009C40B779C1FA64022062D5CD3300F5CD77
:10034000480332A640F1D1C93A3D40E6083A204080
:1003500028030FE61FE63FC9CDC441D5CD2B00D100
:10036000C9AF32994032A640CDAF41C52AA7400659
:10037000F0CDD905F54806000936002AA740F1C19D
:100380002BD8AFC9CD5803B7C018F9AF329C403A4B
:100390009B40B7C83E0DD5CD9C03D1C9F5D5C54FFF
:1003A0001E00FE0C2810FE0A20033E0D4FFE0D28F5
:1003B000053A9B403C5F7B329B4079CD3B00C1D1ED
:1003C000F1C979FE20301EFE0D282AFE0C2030DDFA
:1003D0007E03DD960447CD40043E0AD3F810F7DDD6
:1003E0003605001854FE8030300600D6204F2145D7
:1003F00031094E180EDD7E05B77920033E0A4FFE07
:10040000203816DD7E063C2810DDBE05300BCD40C1
:10041000043E0DD3F8DD360500CD400479D3F8DD78
:100420003405FE0D2804FE0A2013DD360500DD34F8
:1004300004DD7E04DDBE032004DD360401AF79C98E
:10044000CD4B04C8CD8D0228F7F1C9DBF8E6F0FEEC
:1004500030C921BF36111540011800EDB021F93621
:1004600011E541011800EDB0C920DAAF3214422A7B
:10047000A440C9F3DD6E03DD6604DD7E05B7280107
:100480007779FE20DA2105FEC0302CCD76057CE69A
:1004900003F63C6756DD7E05B7280DDD7205DD7E6F
:1004A00006FE2030023EB077DD7503DD7404AF79BF
:1004B000FBC97DE6C06FC9DD7E07B77920CDD6C008
:1004C00028CC473E20CD760510F918C27EDD770591
:1004D000C9AF18F921003C3A1042E6FBCD70053A4D
:1004E0001442E607C8CD04053D18F92B3A1042E640
:1004F0000428012B3620C93A1042E604C4FF047DCB
:10050000E63F2BC011400019C9237DE63FC011C052
:10051000FF19C93A1042F604CD7005237DE6FE6F3F
:10052000C9118E04D5FE0828C2FE0ACAAF05FE0D09
:10053000CAAF05FE0E2895FE0F2896D61528213D38
:1005400028293D28CE3D28AF3D28BE3D28B63D2870
:10055000BD3DCAD4043DCAB2043D28603D2866C9E9
:10056000DD7E07E601EE01DD7707C93A1042EE08AD
:10057000321042D3ECC977233A1042E60428012313
:100580007CFE40C0CD0E05E53A1442E60721003C52
:10059000110004C50140003C09EBB7ED42EB3D20E2
:1005A000F7D5E5B7ED42EBE1C1EDB0C1EB1817CDE2
:1005B000B204E5CD04057CFE4028CDD1E5547DF69E
:1005C0003F5F131804E5110040362023DF20FAE1D5
:1005D000C9524F4EE6F0FE30C9E53E0ECD3300481D
:1005E000CD4900FE203025FE0DCA6206FE1F2829D7
:1005F000FE01286D11E005D5FE082834FE18282BD1
:10060000FE092842FE192839FE0AC0D17778B7289A
:10061000CF7E23CD33000518C7CDC90141E1E5C325
:10062000E005CD30062B7E23FE0AC878B920F3C939
:1006300078B9C82B7EFE0A23C82B3E08CD330004B0
:10064000C93E17C33300CD4803E6072F3CC6085FF9
:1006500078B7C83E207723D5CD3300D1051DC81803
:10066000EF37F53E0D77CD33003E0FCD3300799057
:1006700047F1E1C9E5DDE5D5DDE1D5219406E54F9A
:100680001ACB7F2805A0B8C23340A0FE02DD6E0160
:10069000DD6602E9D1DDE1E1C1C9AF329F4016FF5D
:1006A000C38D2BE6FD329F403E3AB7F2E2063A9FF9
:1006B000401F382E1F1F303E7EFEFBE5C521DF06A2
:1006C000E5C00B0AFE4DC00B0AFE45C00B0AFE52E8
:1006D000C00B0AFE3AC0F1F1E1141414141825C13C
:1006E000E17EC3892B3A9F40F602329F40AFC93A60
:1006F0009F40F60418F41738E97EFE88CCE506FE24
:1007000093CCEF067EC3A02B218013CDC20918061F
:10071000CDC209CD820978B7C83A2441B7CAB40915
:1007200090300C2F3CEBCDA409EBCDB409C1D1FE28
:1007300019D0F5CDDF0967F1CDD707B4212141F2FA
:100740005407CDB707D296072334CAB2072E01CD7E
:10075000EB071842AF90477E9B5F237E9A57237E1C
:10076000994FDCC3076863AF4779B720184A5465CF
:100770006F78D608FEE020F0AF322441C905297A0F
:100780001757798F4FF27D07785C45B728082124E9
:1007900041867730E3C878212441B7FCA807462377
:1007A0007EE680A94FC3B4091CC014C00CC00E80E3
:1007B00034C01E0AC3A2197E835F237E8A57237E1C
:1007C000894FC92125417E2F77AF6F90477D9B5F71
:1007D0007D9A577D994FC90600D6083807435A516C
:1007E0000E0018F5C6096FAF2DC8791F4F7A1F5735
:1007F0007B1F5F781F4718EF0000008103AA56197E
:1008000080F122768045AA3882CD5509B7EA4A1E82
:100810002124417E01358011F30490F570D5C5CDBA
:100820001607C1D104CDA20821F807CD100721FC7D
:1008300007CD9A14018080110000CD1607F1CD89F3
:100840000F013180111872CD5509C82E00CD140941
:1008500079324F41EB225041010000505821650789
:10086000E5216908E5E52121417E23B72824E52E0D
:10087000081F6779300BE52A504119EBE13A4F41E7
:10088000891F4F7A1F577B1F5F781F472D7C20E100
:10089000E1C9435A514FC9CDA40921D80DCDB109A1
:1008A000C1D1CD5509CA9A192EFFCD140934342B64
:1008B0007E3289402B7E3285402B7E32814041EB57
:1008C000AF4F575F328C40E5C57DCD8040DE003FA5
:1008D0003007328C40F1F137D2C1E1793C3D1FFA4B
:1008E0009707177B175F7A175779174F297817479C
:1008F0003A8C4017328C4079B2B320CBE5212441A9
:1009000035E120C3C3B2073EFF2EAF212D414E2358
:10091000AE472E0078B7281F7D212441AE80471FA7
:10092000A878F23609C68077CA9008CDDF09772B00
:10093000C9CD55092FE1B7E1F27807C3B207CDBFA2
:100940000978B7C8C602DAB20747CD160721244195
:1009500034C0C3B2073A2441B7C83A2341FE2F1727
:100960009FC03CC906881100002124414F70060039
:1009700023368017C36207CD9409F0E7FA5B0CCAEF
:10098000F60A2123417EEE8077C9CD94096F179F27
:1009900067C39A0AE7CAF60AF255092A21417CB5CB
:1009A000C87C18BBEB2A2141E3E52A2341E3E5EBB0
:1009B000C9CDC209EB2221416069222341EBC92143
:1009C00021415E2356234E234623C91121410604AB
:1009D0001805EB3AAF40471A7713230520F9C921D0
:1009E00023417E07371F773F1F2323777907371F60
:1009F0004F1FAEC921274111D209180621274111E5
:100A0000D309D5112141E7D8111D41C978B7CA557D
:100A100009215E09E5CD550979C8212341AE79F850
:100A2000CD260A1FA9C92378BEC02B79BEC02B7A58
:100A3000BEC02B7B96C0E1E1C97AAC7CFA5F09BAF3
:100A4000C260097D93C26009C9212741CDD3091134
:100A50002E411AB7CA5509215E09E5CD55091B1A61
:100A60004FC8212341AE79F8132306081A96C223F2
:100A70000A1B2B0520F6C1C9CD4F0AC25E09C9E782
:100A80002A2141F8CAF60AD4B90A21B207E53A2464
:100A900041FE90300ECDFB0AEBD12221413E0232C5
:100AA000AF40C9018090110000CD0C0AC0616A18E6
:100AB000E8E7E0FACC0ACAF60ACDBF09CDEF0A781A
:100AC000B7C8CDDF0921204146C396072A2141CD71
:100AD000EF0A7C551E000690C36909E7D0CAF60AE2
:100AE000FCCC0A210000221D41221F413E08013E8C
:100AF00004C39F0AE7C81E18C3A219474F575FB720
:100B0000C8E5CDBF09CDDF09AE67FC1F0B3E98904D
:100B1000CDD7077C17DCA8070600DCC307E1C91B9B
:100B20007AA33CC00BC9E7F8CD5509F2370BCD824B
:100B300009CD370BC37B09E7F8301E28B9CD8E0AE3
:100B40002124417EFE983A2141D07ECDFB0A369881
:100B50007BF57917CD6207F1C92124417EFE90DA39
:100B60007F0A20144F2B7EEE8006062BB60520FB55
:100B7000B7210080CA9A0A79FEB8D0F5CDBF09CD59
:100B8000DF09AE2B36B8F5FCA00B2123413EB8900F
:100B9000CD690DF1FC200DAF321C41F1D0C3D80C52
:100BA000211D417E35B72328FAC9E521000078B11F
:100BB00028123E1029DA3D27EB29EB300409DA3DF3
:100BC000273D20F0EBE1C97C179F47CD510C799868
:100BD00018037C179F47E57A179F19880FACF29985
:100BE0000AC5EBCDCF0AF1E1CDA409EBCD6B0CC367
:100BF0008F0F7CB5CA9A0AE5D5CD450CC5444D2169
:100C000000003E1029381FEB29EB300409DA260CCE
:100C10003D20F1C1D17CB7FA1F0CD178C34D0CEE49
:100C200080B52813EB01C1E1CDCF0AE1CDA409CDF8
:100C3000CF0AC1D1C3470878B7C1FA9A0AD5CDCF38
:100C40000AD1C382097CAA47CD4C0CEB7CB7F29A3F
:100C50000AAF4F956F799C67C39A0A2A2141CD51FB
:100C60000C7CEE80B5C0EBCDEF0AAF0698C36909E6
:100C7000212D417EEE8077212E417EB7C8472B4E35
:100C80001124411AB7CAF4099030162F3CF50E080A
:100C900023E51A467778121B2B0D20F6E1462B4EE2
:100CA000F1FE39D0F5CDDF0923360047F1212D4182
:100CB000CD690D3A2641321C4178B7F2CF0CCD33C5
:100CC0000DD20E0DEB34CAB207CD900DC30E0DCD73
:100CD000450D212541DC570DAF473A2341B7201E72
:100CE000211C410E0856777A230D20F978D608FE8C
:100CF000C020E6C3780705211C41CD970DB7F2F659
:100D00000C78B728092124418677D27807C83A1C85
:100D100041B7FC200D2125417EE6802B2BAE77C903
:100D2000211D41060734C0230520FA34CAB2072B1F
:100D30003680C9212741111D410E07AF1A8E1213AB
:100D4000230D20F8C9212741111D410E07AF1A9E1E
:100D50001213230D20F8C97E2F77211C410608AFFE
:100D60004F799E77230520F9C971E5D608380EE141
:100D7000E51100084E73592B1520F918EEC60957D6
:100D8000AFE115C8E51E087E1F772B1D20F918F06E
:100D9000212341160118ED0E087E1777230D20F947
:100DA000C9CD5509C8CD0A09CD390E711306071AE8
:100DB00013B7D528170E08C51F47DC330DCD900D8E
:100DC00078C10D20F2D10520E6C3D80C212341CDF6
:100DD000700D18F1000000000000208411D40D21D6
:100DE0002741CDD3093A2E41B7CA9A19CD07093404
:100DF00034CD390E2151417141114A41212741CD54
:100E00004B0D1A993F380B114A41212741CD390D1D
:100E1000AFDA12043A23413C3D1FFA110D17211D90
:100E2000410E07CD990D214A41CD970D78B720C9C4
:100E30002124413520C3C3B20779322D412B1150F3
:100E4000410100077E12711B2B0520F8C9CDFC095A
:100E5000EB2B7EB7C8C602DAB20777E5CD770CE197
:100E600034C0C3B207CD7807CDEC0AF6AFEB01FF73
:100E7000006068CC9A0AEB7EFE2DF5CA830EFE2B2D
:100E800028012BD7DA290FFE2ECAE40EFE452814BE
:100E9000FE25CAEE0EFE23CAF50EFE21CAF60EFE90
:100EA000442024B7CDFB0EE521BD0EE3D715FECEC1
:100EB000C8FE2DC814FECDC8FE2BC82BF1D7DA947E
:100EC0000F142003AF935FE57B90F40A0FFC180F1B
:100ED00020F8E1F1E5CC7B09E1E7E8E5219008E5C0
:100EE000CDA30AC9E70C20DFDCFB0EC3830EE7F2BB
:100EF00097192318D2B7CDFB0E18F7E5D5C5F5CC59
:100F0000B10AF1C4DB0AC1D1E1C9C8F5E7F5E43E95
:100F100009F1EC4D0EF13DC9D5E5F5E7F5E497088B
:100F2000F1ECDC0DF1E1D13CC9D5788947C5E57E0E
:100F3000D630F5E7F25D0F2A214111CD0CDF3019D3
:100F4000545D29291929F14F097CB7FA570F22213D
:100F500041E1C1D1C3830E79F5CDCC0A37301801F8
:100F60007494110024CD0C0AF2740FCD3E09F1CD1A
:100F7000890F18DDCDE30ACD4D0ECDFC09F1CD640E
:100F800009CDE30ACD770C18C8CDA409CD6409C1F9
:100F9000D1C316077BFE0A30090707830786D630C0
:100FA0005FFA1E32C3BD0EE5212419CDA728E1CD7D
:100FB0009A0AAFCD3410B6CDD90FC3A628AFCD3421
:100FC00010E6082802362BEBCD9409EBF2D90F3648
:100FD0002DC5E5CD7B09E1C1B42336303AD8405761
:100FE000173AAF40DA9A10CA9210FE04D23D1001AF
:100FF0000000CD2F13213041460E203AD8405FE645
:1010000020280778B90E2A20014171D72814FE45FF
:101010002810FE44280CFE3028F0FE2C28ECFE2E72
:1010200020032B36307BE61028032B36247BE60486
:10103000C02B70C932D8402130413620C9FE05E5A9
:10104000DE00175714CD011201000382FA57101465
:10105000BA30043C473E02D602E1F5CD911236305B
:10106000CCC909CDA4122B7EFE3028FAFE2EC4C9AD
:1010700009F1281FF5E73E228F7723F1362BF28501
:1010800010362D2F3C062F04D60A30FBC63A2370AB
:101090002377233600EB213041C923C5FE047AD2E1
:1010A00009111FDAA311010306CD8912D17AD605E1
:1010B000F46912CD2F137BB7CC2F093DF46912E5EB
:1010C000CDF50FE1280270233600212F41233AF39A
:1010D000409592C87EFE2028F4FE2A28F02BE5F5E4
:1010E00001DF10C5D7FE2DC8FE2BC8FE24C8C1FEE7
:1010F00030200F23D7300B2B012B77F128FBC1C3F6
:10110000CE10F128FDE13625C9E51FDAAA11281411
:10111000118413CD490A1610FA3211E1C1CDBD0F69
:101120002B3625C9010EB611CA1BCD0C0AF21B11B4
:101130001606CD5509C40112E1C1FA5711C55F78F1
:101140009293F46912CD7D12CDA412B3C47712B379
:10115000C49112D1C3B6105F79B7C4160F83FA6277
:1011600011AFC5F5FC180FFA6411C17B90C15F8205
:1011700078FA7F119293F46912C5CD7D121811CDC2
:10118000691279CD94124FAF9293CD6912C5474F32
:10119000CDA412C1B120032AF340833DF46912505B
:1011A000C3BF10E5D5CDCC0AD1AFCAB0111E100116
:1011B0001E06CD550937C40112E1C1F579B7F5C452
:1011C000160F804F7AE604FE019F57814F93F5C5B5
:1011D000FC180FFAD011C1F1C5F5FADE11AF2F3CA2
:1011E000803C82470E00CDA412F1F47112C1F1CC03
:1011F0002F09F13803839092C5CD7410EBD1C3BF92
:1012000010D5AFF5E7E222123A2441FE91D2221224
:10121000116413212741CDD309CDA10DF1D60AF5D3
:1012200018E6CD4F12E7300B01439111F94FCD0C69
:101230000A1806116C13CD490AF24B12F1CD0B0FAF
:10124000F518E2F1CD180FF5CD4F12F1D1B7C9E77E
:10125000EA5E1201749411F823CD0C0A1806117479
:1012600013CD490AE1F24312E9B7C83D36302318DD
:10127000F92004C8CD91123630233D18F67B823C0C
:10128000473CD60330FCC6054F3AD840E640C04F35
:10129000C9052008362E22F3402348C90DC0362C3C
:1012A000230E03C9D5E7E2EA12C5E5CDFC09217C8E
:1012B00013CDF709CD770CAFCD7B0BE1C1118C13AA
:1012C0003E0ACD9112C5F5E5D5062F04E1E5CD48DE
:1012D0000D30F8E1CD360DEBE17023F1C13D20E298
:1012E000C5E5211D41CDB109180CC5E5CD08073C68
:1012F000CDFB0ACDB409E1C1AF11D2133FCD91129C
:10130000C5F5E5D5CDBF09E1062F047B965F237AAD
:101310009E5723799E4F2B2B30F0CDB70723CDB4AA
:1013200009EBE17023F1C138D313133E041806D53D
:1013300011D8133E05CD9112C5F5E5EB4E2346C5F8
:1013400023E3EB2A2141062F047D936F7C9A6730BB
:10135000F719222141D1E17023F1C13D20D7CD9170
:101360001277D1C900000000F90215A2FDFF9F31DC
:10137000A95F63B2FEFF03BFC91B0EB600000000E9
:1013800000000080000004BFC91B0EB60080C6A488
:101390007E8D0300407A10F35A0000A0724E1809A7
:1013A000000010A5D4E8000000E87648170000000F
:1013B000E40B5402000000CA9A3B00000000E1F573
:1013C000050000008096980000000040420F0000D9
:1013D0000000A086011027001027E80364000A001F
:1013E0000100218209E3E9CDA409218013CDB109CF
:1013F0001803CDB10AC1D1CD550978283CF20414A7
:10140000B7CA9A19B7CA7907D5C579F67FCDBF098A
:10141000F22114D5C5CD400BC1D1F5CD0C0AE17C2C
:101420001FE1222341E1222141DCE213CC8209D5D4
:10143000C5CD0908C1D1CD4708CDA4090138811116
:101440003BAACD47083A2441FE88D23109CD400B52
:10145000C680C602DA3109F521F807CD0B07CD4168
:1014600008F1C1D1F5CD1307CD8209217914CDA999
:1014700014110000C14AC3470808402E9474704FED
:101480002E776E02887AE6A02A7C50AAAA7EFFFFF9
:101490007F7F0000808100000081CDA40911320C03
:1014A000D5E5CDBF09CD4708E1CDA4097E23CDB157
:1014B0000906F1C1D13DC8D5C5F5E5CD4708E1CD57
:1014C000C209E5CD1607E118E9CD7F0A7CB7FA4AD3
:1014D0001EB5CAF014E5CDF014CDBF09EBE3C5CDC0
:1014E000CF0AC1D1CD470821F807CD0B07C3400B68
:1014F000219040E51100004B26032E08EB29EB79E3
:10150000174FE37E0777E3D21615E52AAA4019EBB9
:101510003AAC40894FE12DC2FC14E323E325C2FA23
:1015200014E12165B01922AA40CDEF0A3E058932A7
:10153000AC40EB0680212541702B704F0600C3653F
:1015400007218B15CD0B07CDA40901498311DB0FB2
:10155000CDB409C1D1CDA208CDA409CD400BC1D1D4
:10156000CD1307218F15CD1007CD550937F277150B
:10157000CD0807CD5509B7F5F48209218F15CD0B9C
:1015800007F1D48209219315C39A14DB0F49810016
:1015900000007F05BAD71E866426998758342387B2
:1015A000E05DA586DA0F4983CDA409CD4715C1E1D9
:1015B000CDA409EBCDB409CD4115C3A008CD550983
:1015C000FCE213FC82093A2441FE81380C010081BF
:1015D0005159CDA208211007E521E315CD9A142118
:1015E0008B15C9094AD73B78026E847BFEC12F7CDC
:1015F00074319A7D843D5A7DC87F917EE4BB4C7ED8
:101600006CAAAA7F000000818A09370B7709D427CA
:10161000EF2AF527E713C9140908391441154715AE
:10162000A815BD15AA2C524158415E416141644143
:1016300067416A416D4170417F0AB10ADB0A260B9E
:10164000032A3628C52A0F2A1F2A612A912A9A2A94
:10165000C54E44C64F52D245534554D34554C34C4E
:1016600053C34D44D2414E444F4DCE455854C441CE
:101670005441C94E505554C4494DD2454144CC45BE
:1016800054C74F544FD2554EC946D24553544F526A
:1016900045C74F535542D2455455524ED2454DD36E
:1016A000544F50C54C5345D4524F4ED4524F4646DA
:1016B000C44546535452C44546494E54C445465306
:1016C0004E47C4454644424CCC494E45C544495416
:1016D000C552524F52D24553554D45CF5554CF4E1A
:1016E000CF50454EC649454C44C74554D05554C3C8
:1016F0004C4F5345CC4F4144CD45524745CE414DCB
:1017000045CB494C4CCC534554D2534554D3415608
:1017100045D3595354454DCC5052494E54C4454677
:10172000D04F4B45D052494E54C34F4E54CC4953E1
:1017300054CC4C495354C4454C455445C155544F61
:10174000C34C454152C34C4F4144C353415645CE0F
:101750004557D4414228D44FC64ED553494E47D65B
:101760004152505452D55352C5524CC55252D35483
:1017700052494E4724C94E535452D04F494E54D427
:10178000494D4524CD454DC94E4B455924D4484576
:101790004ECE4F54D3544550ABADAAAFDBC14E44EF
:1017A000CF52BEBDBCD3474EC94E54C14253C652A0
:1017B00045C94E50D04F53D35152D24E44CC4F47CF
:1017C000C55850C34F53D3494ED4414EC1544ED047
:1017D00045454BC35649C35653C35644C54F46CCE3
:1017E0004F43CC4F46CD4B4924CD4B5324CD4B4496
:1017F00024C3494E54C3534E47C344424CC6495870
:10180000CC454ED3545224D6414CC15343C34852C5
:1018100024CC45465424D24947485424CD49442435
:10182000A780AE1DA11C38013501C9017341D30148
:10183000B622051F9A210826EF21211FC21EA31ED2
:101840003920911DB11EDE1E071FA91D071FF71DA0
:10185000F81D001E031E061E091EA341602EF41F64
:10186000AF1FFB2A6C1F79417C417F41824185413A
:1018700088418B418E41914197419A41A041B202EA
:1018800067205B41B12C6F20E41D2E2B292BC62B2A
:1018900008207A1E1F2CF52B491B79797C7C7F5000
:1018A00046DB0A00007F0AF40AB10A770C700CA12B
:1018B0000DE50D780A160713074708A2080C0AD28F
:1018C0000BC70BF20B9024390A4E46534E52474F2A
:1018D0004446434F564F4D554C425344442F304994
:1018E00044544D4F534C535354434E4E52525755FC
:1018F000454D4F46444C33D6006F7CDE006778DEA2
:1019000000473E00C94A1E40E64DDB00C9D300C96E
:10191000000000004030004C44FEFFE943204572C7
:10192000726F720020696E200052454144590D00CB
:10193000427265616B00210400397E23FE81C04E36
:10194000234623E569607AB3EB2802EBDF010E0042
:10195000E1C80918E5CD6C19C5E3C1DF7E02C80BEB
:101960002B18F8E52AFD40060009093EE53EC6951C
:101970006F3EFF9C38046739E1D81E0C18242AA258
:10198000407CA53C28083AF240B71E222014C3C16F
:101990001D2ADA4022A2401E02011E14011E00016F
:1019A0001E242AA24022EA4022EC4001B4192AE86F
:1019B00040C39A1BC17B4B329A402AE64022EE403C
:1019C000EB2AEA407CA53C280722F540EB22F740B1
:1019D0002AF0407CB5EB21F2402808A6200535EB23
:1019E000C3361DAF7759CDF92021C918CDA641576F
:1019F0003E3FCD2A03197ECD2A03D7CD2A03211DD0
:101A000019E52AEA40E3CDA728E111FEFFDFCA74F9
:101A1000067CA53CC4A70F3EC1CD8B03CDAC41CD08
:101A2000F801CDF920212919CDA7283A9A40D602EC
:101A3000CC532E21FFFF22A2403AE140B728372A9B
:101A4000E240E5CDAF0FD1D5CD2C1B3E2A38023E6A
:101A500020CD2A03CD6103D13006AF32E14018B961
:101A60002AE4401938F4D511F9FFDFD130EC22E235
:101A700040F6FFC3EB2F3E3ECD2A03CD6103DA33A0
:101A80001AD73C3DCA331AF5CD5A1E2B7EFE2028AC
:101A9000FA237EFE20CCC909D5CDC01BD1F122E6A8
:101AA00040CDB241D25A1DD5C5AF32DD40D7B7F5D2
:101AB000EB22EC40EBCD2C1BC5DCE42BD1F1D5287F
:101AC00027D12AF940E3C109E5CD5519E122F940B2
:101AD000EB74D1E5232373237223EB2AA740EB1B7E
:101AE0001B1A772313B720F9D1CDFC1ACDB541CD00
:101AF0005D1BCDB841C3331A2AA440EB626B7E2331
:101B0000B6C8232323AFBE2320FCEB73237218EC4B
:101B1000110000D52809D1CD4F1ED5280BCFCE11ED
:101B2000FAFFC44F1EC29719EBD1E3E52AA4404443
:101B30004D7E23B62BC823237E23666FDF60697E2C
:101B400023666F3FC83FD018E6C0CDC9012AA44024
:101B5000CDF81D32E1407723772322F940CD6B0485
:101B60002B22DF40061A21014136042310FBAF323D
:101B7000F2406F6722F04022F7402AB14022D6405F
:101B8000CD911D2AF94022FB4022FD40CDBB41C131
:101B90002AA0402B2B22E8402323F921B54022B371
:101BA00040CD8B03CD6921AF676F32DC40E5C52A9C
:101BB000DF40C93E3FCD2A033E20CD2A03C3610347
:101BC000AF32B0404FEB2AA7402B2BEB7EFE20CA52
:101BD0005B1C47FE22CA771CB7CA7D1C3AB040B7CF
:101BE0007EC25B1CFE3F3EB2CA5B1C7EFE303805E7
:101BF000FE3CDA5B1CD5114F16C5013D1CC5067FA6
:101C00007EFE613807FE7B3003E65F774EEB23B63E
:101C1000F20E1C047EE67FC8B920F3EBE5131AB779
:101C2000FA391C4F78FE8D2002D72B237EFE6138B7
:101C300002E65FB928E7E118D348F1EBC9EB79C1B7
:101C4000D1EBFE95363A20020C23FEFB200C363AEF
:101C50002306937023EB0C0C181DEB2312130CD6E8
:101C60003A2804FE4E200332B040D659C2CC1B475E
:101C70007EB72809B828E423120C1318F3210500B5
:101C80004409444D2AA7402B2B2B1213121312C9BF
:101C90007C92C07D93C97EE3BE23E3CA781DC397BF
:101CA000193E6432DC40CD211FE3CD3619D1200529
:101CB00009F922E840EB0E08CD6319E5CD051FE3D5
:101CC000E52AA240E3CFBDE7CAF60AD2F60AF5CD6F
:101CD0003723F1E5F2EC1CCD7F0AE31101007EFE13
:101CE000CCCC012BD5E5EBCD9E091822CDB10ACD88
:101CF000BF09E1C5D5010081515A7EFECC3E0120CD
:101D00000ECD3823E5CDB10ACDBF09CD5509E1C5CA
:101D1000D54FE747C5E52ADF40E30681C533CD58F7
:101D200003B7C4A01D22E640ED73E8407EFE3A28CA
:101D300029B7C29719237E23B6CA7E19235E23567C
:101D4000EB22A2403A1B41B7280FD53E3CCD2A03D7
:101D5000CDAF0F3E3ECD2A03D1EBD7111E1DD5C806
:101D6000D680DA211FFE3CD2E72A074F0600EB217E
:101D70002218094E2346C5EB237EFE3AD0FE20CA28
:101D8000781DFE0B3005FE09D2781DFE303F3C3D2C
:101D9000C9EB2AA4402B22FF40EBC9CD5803B7C89A
:101DA000FE60CC84033299403DC03CC3B41DC0F5F5
:101DB000CCBB41F122E64021B54022B34021F6FFE1
:101DC000C12AA240E5F57DA43C280922F5402AE677
:101DD0004022F740CD8B03CDF920F1213019C20606
:101DE0001AC3181A2AF7407CB51E20CAA219EB2A7A
:101DF000F54022A240EBC93EAF321B41C9F1E1C917
:101E00001E03011E02011E04011E08CD3D1E019786
:101E100019C5D8D6414F47D7FECE2009D7CD3D1E94
:101E2000D8D64147D77891D83CE321014106000933
:101E300073233D20FBE17EFE2CC0D718CE7EFE41F1
:101E4000D8FE5B3FC9D7CD022BF01E08C3A2197E76
:101E5000FE2EEB2AEC40EBCA781D2B110000D7D0E8
:101E6000E5F5219819DFDA9719626B19291929F11B
:101E7000D6305F160019EBE118E4CA611BCD461E8F
:101E80002BD7C0E52AB1407D935F7C9A57DA7A1947
:101E90002AF94001280009DFD27A19EB22A040E19B
:101EA000C3611BCA5D1BCDC741CD611B011E1D183F
:101EB000100E03CD6319C1E5E52AA240E33E91F57A
:101EC00033C5CD5A1ECD071FE52AA240DFE123DC32
:101ED0002F1BD42C1B60692BD81E0EC3A219C01651
:101EE000FFCD3619F922E840FE911E04C2A219E185
:101EF00022A240237CB520073ADD40B7C2181A2140
:101F00001E1DE33EE1013A0E0006007948477EB708
:101F1000C8B8C823FE2228F3D68F20F2B88A5718F3
:101F2000EDCD0D26CFD5EB22DF40EBD5E7F5CD3754
:101F300023F1E3C603CD1928CD030AE520282A2181
:101F400041E5235E23562AA440DF300E2AA040DF5D
:101F5000D1300F2AF940DF30093ED1CDF529EBCD44
:101F60004328CDF529E3CDD309D1E1C9FE9E202533
:101F7000D7CF8DCD5A1E7AB32809CD2A1B5059E1EF
:101F8000D2D91EEB22F040EBD83AF240B7C83A9AC9
:101F9000405FC3AB19CD1C2B7E47FE912803CF8D2C
:101FA0002B4B0D78CA601DCD5B1EFE2CC018F311A3
:101FB000F2401AB7CAA0193C329A40127EFE872816
:101FC0000CCD5A1EC07AB3C2C51E3C1802D7C02A17
:101FD000EE40EB2AEA4022A240EBC07EB720042369
:101FE000232323237AA33CC2051F3ADD403DCABE0A
:101FF0001DC3051FCD1C2BC0B7CA4A1E3D875FFEFF
:102000002D38021E26C3A219110A00D52817CD4F5C
:102010001EEBE32811EBCF2CEB2AE440EB2806CD96
:102020005A1EC29719EB7CB5CA4A1E22E44032E11F
:1020300040E122E240C1C3331ACD37237EFE2CCCCF
:10204000781DFECACC781D2BE5CD9409E12807D771
:10205000DAC21EC35F1D1601CD051FB7C8D7FE9596
:1020600020F61520F318E83E01329C40C37C20CDB9
:10207000CA41FE232006CD8402329C402BD7CCFEE1
:1020800020CA6921F620FE60201BCD012BFE04D260
:102090004A1EE521003C192220407BE63F32A64043
:1020A000E1CF2C18C77EFEBFCABD2CFEBCCA3721AB
:1020B000E5FE2C2853FE3B285ECD3723E3E728328C
:1020C000CDBD0FCD6528CDCD412A21413A9C40B7E9
:1020D000FAE92028083A9B4086FE8418093A9D4078
:1020E000473AA64086B8D4FE20CDAA283E20CD2A65
:1020F00003B7CCAA28E1C37C203AA640B7C83E0D5E
:10210000CD2A03CDD041AFC9CDD3413A9C40B7F2DF
:1021100019213E2CCD2A03184B28083A9B40FE700B
:10212000C32B213A9E40473AA640B8D4FE20303413
:10213000D61030FC2F1823CD1B2BE67F5FCF292B29
:10214000E5CDD3413A9C40B7FA4A1ECA53213A9B87
:102150004018033AA6402F83300A3C473E20CD2A40
:10216000030520FAE1D7C381203A9C40B7FCF8016F
:10217000AF329C40CDBE41C93F5245444F0D003A5D
:10218000DE40B7C291193AA940B71E2ACAA219C1A6
:10219000217821CDA7282AE640C9CD28287ECDD692
:1021A00041D62332A9407E2020CD9302E506FA2AAB
:1021B000A740CD35027723FE0D280210F52B3600FF
:1021C000CDF8012AA7402B182201DB21C5FE22C031
:1021D000CD6628CF3BE5CDAA28E1C9E5CDB31BC12B
:1021E000DABE1D237EB72BC5CA041F362C1805E5A1
:1021F0002AFF40F6AF32DE40E31802CF2CCD0D2689
:10220000E3D57EFE2C28263ADE40B7C296223AA9B4
:1022100040B71E06CAA2193E3FCD2A03CDB31BD13B
:10222000C1DABE1D237EB72BC5CA041FD5CDDC4144
:10223000E7F52019D75747FE222805163A062C2B1A
:10224000CD6928F1EB215A22E3D5C3331FD7F1F52D
:10225000014322C5DA6C0ED2650E2BD72805FE2C61
:10226000C27F21E32BD7C2FB21D100000000003A3E
:10227000DE40B7EBC2961DD5CDDF41B6218622C424
:10228000A728E1C369213F45787472612069676EB0
:102290006F7265640D00CD051FB72012237E23B633
:1022A0001E06CAA219235E2356EB22DA40EBD7FEA4
:1022B0008820E3C32D22110000C40D2622DF40CD6B
:1022C0003619C29D19F922E840D57E23F5D57E2323
:1022D000B7FAEA22CDB109E3E5CD0B07E1CDCB0991
:1022E000E1CDC209E5CD0C0A1829232323234E236F
:1022F0004623E35E2356E56960CDD20B3AAF40FE3C
:1023000004CAB207EBE1722B73E1D55E235623E3D7
:10231000CD390AE1C190CDC2092809EB22A240695A
:1023200060C31A1DF922E8402ADF407EFE2CC21E3F
:102330001DD7CDB922CF282B1600D50E01CD63199C
:10234000CD9F2422F3402AF340C17E1600D6D43814
:1023500013FE03300FFE0117AABA57DA971922D8D5
:1023600040D718E97AB7C2EC237E22D840D6CDD820
:10237000FE07D05F3AAF40D603B3CA8F29219A181F
:10238000197856BAD0C5014623C57AFE7FCAD42330
:10239000FE51DAE123212141B73AAF403D3D3DCA2C
:1023A000F60A4E2346C5FAC523234E2346C5F5B784
:1023B000E2C423F1233803211D414E234623C54E99
:1023C0002346C506F1C6034B47C5010624C52AD8D6
:1023D00040C33A23CDB10ACDA40901F213167F18E8
:1023E000ECD5CD7F0AD1E501E92518E178FE64D06E
:1023F000C5D511046421B825E5E7C295232A2141FA
:10240000E5018C2518C7C17932B04078FE0828282C
:102410003AAF40FE08CA60245778FE04CA72247A94
:10242000FE03CAF60AD27C2421BF18060009094E11
:102430002346D12A2141C5C9CDDB0ACDFC09E122C1
:102440001F41E1221D41C1D1CDB409CDDB0A21AB31
:10245000183AB04007C54F060009C17E23666FE9F0
:10246000C5CDFC09F132AF40FE0428DAE12221415A
:1024700018D9CDB10AC1D121B51818D5E1CDA4091B
:10248000CDCF0ACDBF09E1222341E122214118E746
:10249000E5EBCDCF0AE1CDA409CDCF0AC3A008D783
:1024A0001E28CAA219DA6C0ECD3D1ED24025FECDE3
:1024B00028EDFE2ECA6C0EFECECA3225FE22CA665A
:1024C00028FECBCAC425FE26CA9441FEC3200AD7E3
:1024D0003A9A40E5CDF827E1C9FEC2200AD7E52A9D
:1024E000EA40CD660CE1C9FEC02014D7CF28CD0D3F
:1024F00026CF29E5EB7CB5CA4A1ECD9A0AE1C9FE72
:10250000C1CAFE27FEC5CA9D41FEC8CAC927FEC76B
:10251000CA7641FEC6CA3201FEC9CA9D01FEC4CABE
:102520002F2AFEBECA5541D6D7D24E25CD3523CF50
:1025300029C9167DCD3A232AF340E5CD7B09E1C9AF
:10254000CD0D26E5EB222141E7C4F709E1C90600DC
:10255000074FC5D779FE413816CD3523CF2CCDF4A2
:102560000AEB2A2141E3E5EBCD1C2BEBE31814CD5C
:102570002C25E37DFE0C3807FE1BE5DCB10AE111DA
:102580003E25D5010816094E236669E9CDD7297E77
:10259000234E2346D1C5F5CDDE29D15E234E2346F9
:1025A000E17BB2C87AD601D8AFBB3CD0151D0ABEBC
:1025B000230328ED3FC360093C8FC1A0C6FF9FCD18
:1025C0008D091812165ACD3A23CD7F0A7D2F6F7CC4
:1025D0002F67222141C1C346233AAF40FE08300590
:1025E000D603B737C9D603B7C9C5CD7F0AF1D10124
:1025F000FA27C5FE4620067BB56F7CB2C97BA56F66
:102600007CA2C92BD7C8CF2C010326C5F6AF32AEAA
:102610004046CD3D1EDA9719AF4FD73805CD3D1E48
:1026200038094FD738FDCD3D1E30F8115226D5164A
:1026300002FE25C814FE24C814FE21C81608FE2375
:10264000C878D641E67F5F1600E52101411956E1C1
:102650002BC97A32AF40D73ADC40B7C264267ED667
:1026600028CAE926AF32DC40E5D52AF940EB2AFB3F
:1026700040DFE128191A6FBC13200B1AB920071389
:102680001AB8CACC263E1313E526001918DF7CE1E0
:10269000E3F5D511F124DF2836114325DFD12835A4
:1026A000F1E3E5C54F0600C50303032AFD40E50934
:1026B000C1E5CD5519E122FD40606922FB402B3672
:1026C00000DF20FAD17323D1732372EB13E1C957D2
:1026D0005FF1F1E3C9322441C1676F222141E72054
:1026E00006212819222141E1C9E52AAE40E357D548
:1026F000C5CD451EC1F1EBE3E5EB3C577EFE2C2832
:10270000EECF2922F340E122AE40D52AFB403E190C
:10271000EB2AFD40EBDF3AAF402827BE2320087E9E
:10272000B92320047EB83E23235E23562320E03ABB
:10273000AE40B71E12C2A219F196CA95271E10C349
:10274000A21977235F1600F1712370234FCD63190F
:10275000232322D84071233AAE401779010B003071
:1027600002C10371237023F5CDAA0BF13D20EDF5D5
:10277000424BEB1938C7CD6C1922FD402B3600DFD8
:1027800020FA03572AD8405EEB2909EB2B2B732341
:102790007223F13830474F7E2316E15E235623E340
:1027A000F5DFD23D27CDAA0B19F13D444D20EB3A80
:1027B000AF40444D29D604380429280629B7E2C27F
:1027C0002709C109EB2AF340C9AFE532AF40CDD4A8
:1027D00027E1D7C92AFD40EB21000039E7200DCDC4
:1027E000DA29CDE6282AA040EB2AD6407D936F7CDB
:1027F0009A67C3660C3AA6406FAF67C39A0ACDA921
:1028000041D7CD2C25E5219008E53AAF40F5FE03F0
:10281000CCDA29F1EB2A8E40E9E5E60721A1184F31
:10282000060009CD8625E1C9E52AA240237CB5E151
:10283000C01E16C3A219CDBD0FCD6528CDDA290162
:102840002B2AC57E23E5CDBF28E14E2346CD5A284D
:10285000E56FCDCE29D1C9CDBF2821D340E577235F
:10286000732372E1C92B062250E50EFF237E0CB7BD
:102870002806BA2803B820F4FE22CC781DE323EB07
:1028800079CD5A2811D3403ED52AB3402221413E6A
:102890000332AF40CDD30911D640DF22B340E17EF1
:1028A000C01E1EC3A21923CD6528CDDA29CDC409C7
:1028B0001415C80ACD2A03FE0DCC03210318F2B764
:1028C0000EF1F52AA040EB2AD6402F4F06FF092330
:1028D000DF380722D64023EBF1C9F11E1ACAA2192C
:1028E000BFF501C128C52AB14022D640210000E52C
:1028F0002AA040E521B540EB2AB340EBDF01F728E1
:10290000C24A292AF940EB2AFB40EBDF28137E2339
:102910002323FE032004CD4B29AF5F16001918E6D0
:10292000C1EB2AFD40EBDFCA6B297E23CDC209E54E
:1029300009FE0320EB22D840E14E0600090923EBF3
:102940002AD840EBDF28DA013F29C5AFB6235E2342
:102950005623C8444D2AD640DF6069D8E1E3DFE35F
:10296000E56069D0C1F1F1E5D5C5C9D1E17DB4C853
:102970002B462B4EE52B6E26000950592B444D2A31
:10298000D640CD5819E171237069602BC3E928C581
:10299000E52A2141E3CD9F24E3CDF40A7EE52A21F7
:1029A00041E5861E1CDAA219CD5728D1CDDE29E3D8
:1029B000CDDD29E52AD440EBCDC629CDC629214954
:1029C00023E3E5C38428E1E37E234E23466F2C2DC9
:1029D000C80A12031318F8CDF40A2A2141EBCDF5E9
:1029E00029EBC0D550591B4E2AD640DF2005470998
:1029F00022D640E1C92AB3402B462B4E2BDFC02202
:102A0000B340C901F827C5CDD729AF577EB7C90153
:102A1000F827C5CD072ACA4A1E235E23561AC93E87
:102A200001CD5728CD1F2B2AD44073C1C38428D78A
:102A3000CF28CD1C2BD5CF2CCD3723CF29E3E5E7ED
:102A40002805CD1F2B1803CD132AD1F5F57BCD57C3
:102A5000285FF11C1D28D42AD44077231D20FB18A1
:102A6000CACDDF2AAFE34F3EE5E57EB838027811E4
:102A70000E00C5CDBF28C1E1E523462366680600E8
:102A800009444DCD5A286FCDCE29D1CDDE29C3843E
:102A900028CDDF2AD1D51A9018CBEB7ECDE22A04BF
:102AA00005CA4A1EC51EFFFE292805CF2CCD1C2BAA
:102AB000CF29F1E301692AC53DBE0600D04F7E91C2
:102AC000BB47D843C9CD072ACAF8275F237E2366B0
:102AD0006FE5194672E3C57ECD650EC1E170C9EBA5
:102AE000CF29C1D1C543C9FE7AC29719C3D941CDF7
:102AF0001F2B329440CD9340C3F827CD0E2BC396A5
:102B000040D7CD3723E5CD7F0AEBE17AB7C9CD1C9D
:102B10002B329440329740CF2C1801D7CD3723CD9C
:102B2000052BC24A1E2BD77BC93E01329C40C1CD2A
:102B3000101BC521FFFF22A240E1D14E234623787E
:102B4000B1CA191ACDDF41CD9B1DC54E234623C501
:102B5000E3EBDFC1DA181AE3E5C5EB22EC40CDAFB9
:102B60000F3E20E1CD2A03CD7E2B2AA740CD752B29
:102B7000CDFE2018BE7EB7C8CD2A032318F7E52A5C
:102B8000A740444DE1C39A06000315C8237EB7024F
:102B9000C8C32D30FEFB20080B0B0B0B14141414B0
:102BA000FE95CC240BD67FE55F2150167EB723F22D
:102BB000AC2B1D20F7E67F020315CAD8287E23B769
:102BC000F2B72BE118C6CD101BD1C5C5CD2C1B30DB
:102BD00005545DE3E5DFD24A1E212919CDA728C19E
:102BE00021E81AE3EB2AF9401A020313DF20F96007
:102BF0006922F940C9CD8402CD3723E5CD132A3EA1
:102C0000D3CD6402CD61021ACD64022AA440EB2A1E
:102C1000F9401A13CD6402DF20F8CDF801E1C9D6DE
:102C2000B22802AF012F23F57EB72807CD3723CD79
:102C3000132A1A6FF1B767222141CC4D1B210000E6
:102C4000CD93022A2141EB0603CD3502D6D320F7DE
:102C500010F7CD35021C1D2803BB20372AA44006DF
:102C600003CD35025F96A2202173CD6C197EB72368
:102C700020EDCD2C0210EA22F940CDF801212919CE
:102C8000CDA7282AA440E5C3E81ACDBD31CDA72899
:102C9000C3181A323E3C0603CD3502B720F810F8AF
:102CA000CD960218A24241440D00CD7F0A7EC3F8A2
:102CB00027CD022BD5CF2CCD1C2BD112C9CD38233B
:102CC000CDF40ACF3BEB2A214118083ADE40B72861
:102CD0000CD1EBE5AF32DE40BAF5D546B0CA4A1E9C
:102CE000234E236669181C58E50E027E23FE25CA72
:102CF000172EFE2020030C10F2E1433E25CD492E75
:102D0000CD2A03AF5F57CD492E577E23FE21CA142B
:102D10002EFE23283705CAFE2DFE2B3E0828E72B62
:102D20007E23FE2E2840FE2528BDBE20D0FE24286E
:102D300014FE2A20C878FE022338037EFE243E209B
:102D40002007051CFEAFC610231C82571C0E000571
:102D500028477E23FE2E2818FE2328F0FE2C201A5A
:102D60007AF6405718E67EFE233E2E20900E012371
:102D70000C0528257E23FE2328F6D511972DD55442
:102D80005DFE5BC0BEC023BEC023BEC02378D60498
:102D9000D8D1D1471423CAEBD17A2B1CE6082015D1
:102DA0001D78B728107ED62D2806FEFE20073E0887
:102DB000C604825705E1F12850C5D5CD3723D1C1CE
:102DC000C5E5437881FE19D24A1E7AF680CDBE0F42
:102DD000CDA728E12BD737280D32DE40FE3B280552
:102DE000FE2CC29719D7C1EBE1E5F5D57E90234EB5
:102DF00023666916005F1978B7C2032D1806CD49FE
:102E00002ECD2A03E1F1C2CB2CDCFE20E3CDDD295F
:102E1000E1C369210E013EF105CD492EE1F128E91A
:102E2000C5CD3723CDF40AC1C5E52A2141410E00A5
:102E3000C5CD682ACDAA282A2141F196473E200413
:102E400005CAD32DCD2A0318F7F57AB73E2BC42A2D
:102E500003F1C9329A402AEA40B4A53CEBC81804F1
:102E6000CD4F1EC0E1EB22EC40EBCD2C1BD2D91E86
:102E7000606923234E234623C5CD7E2BE1E5CDAFEC
:102E80000F3E20CD2A032AA7403E0ECD2A03E50E91
:102E9000FF0C7EB72320FAE1471600CD8403D6301D
:102EA000380EFE0A300A5F7A07078207835718EB4D
:102EB000E521992EE31514C2BB2E14FED8CAD22FD9
:102EC000FEDDCAE02FFEF02841FE313802D620FE9A
:102ED00021CAF62FFE1CCA402FFE23283FFE19CA26
:102EE0007D2FFE14CA4A2FFE13CA652FFE15CAE3B2
:102EF0002FFE28CA782FFE1B281CFE18CA752FFE2D
:102F000011C0C1D1CDFE20C3652E7EB7C804CD2A25
:102F100003231520F5C9E5215F2FE337F5CD8403A1
:102F20005FF1F5DC5F2F7EB7CA3E2FCD2A03F1F5A6
:102F3000DCA12F380223047EBB20EB1520E8F1C969
:102F4000CD752BCDFE20C1C37C2E7EB7C83E21CDD2
:102F50002A037EB72809CD2A03CDA12F1520F33EE1
:102F600021CD2A03C97EB7C8CD840377CD2A032398
:102F7000041520F1C936004816FFCD0A2FCD840371
:102F8000B7CA7D2FFE08280AFE0DCAE02FFE1BC817
:102F9000201E3E080504281FCD2A032B05117D2F76
:102FA000D5E50D7EB737CA9008237E2B772318F31B
:102FB000F579FEFF3803F118C4900C04C5EB6F26B9
:102FC0000019444D23CD5819C1F177CD2A0323C3ED
:102FD0007D2F78B7C8052B3E08CD2A031520F3C9ED
:102FE000CD752BCDFE20C1D17AA33C2AA7402BC89A
:102FF0003723F5C3981AC1D1C3191ADEC3C344B22B
:10300000C35E32C39B32C37432C3DA32C3C031C32E
:10301000D131C3AB34C35534C3C235C3FB35C35AF6
:1030200036C38036C38E33C33937C3F731C37B37DA
:10303000C39937C3BB35C3A035DBE4CB6FC31C35A5
:1030400018D3C3B537406162636465666768696AAF
:103050006B6C6D6E6F707172737475767778797A48
:103060003AEA37B7C9303132333435363738393A3E
:103070003B2C2D2E2F0D1F015B0A08092021DC059A
:1030800022FF41AFC9604142434445464748494A4F
:103090004B4C4D4E4F505152535455565758595A08
:1030A00077AFC9AAAA002122232425262728292A66
:1030B0002B3C3D3E3F0D1F011B1A1819203E0121DC
:1030C0001940AE18DB404142434445464748494A0F
:1030D0004B4C4D4E4F505152535455565758595AC8
:1030E000CDD901AFC9303132333435363738393A7A
:1030F0003B2C2D2E2F0D1F015B0A08092028E1A66D
:10310000FE01C0EFC9604142434445464748494A31
:103110004B4C4D4E4F505152535455565758595A87
:103120001423CB01C9002122232425262728292A5C
:103130002B3C3D3E3F0D1F011B1A1819203AFD4143
:103140006F3AFE41C9202122232425262728292A37
:103150002B2C2D2E2F303132333435363738393A47
:103160003B3C3D3E3F404142434445464748494A37
:103170004B4C4D4E4F505152535455565758595A27
:103180005B5C5D5E5F406162636465666768696A37
:103190006B6C6D6E6F707172737475767778797A07
:1031A0007B7C7D7E7F3E01D3FF060D10FE3E02D369
:1031B000FF060D10FECDF331067810FEC921A52CB7
:1031C0003A1342D3E0DBFF3A1042E6FDCDED31FB8E
:1031D000C9EBE3C5E5EBDBEC112020ED533E3CCD24
:1031E000E83101007DC360003A1042F6023210421D
:1031F000D3ECC9AFD3FFC97ED623C25302CD012B76
:10320000CF2CC90608CD203210FB3A12423CE65FB3
:1032100032124220083A3F3CEE0A323F3C7A18789C
:10322000C5DBFF173808CD8D0228F6C35C33066E68
:1032300010FECDF331069810FEDBFFC117CB12183C
:10324000B2F5C5D50E0857CDA531CB02300ACDA5B4
:10325000310D20F3D1C1F1C9069A10FE18F3E52112
:103260004132220C420653AFCD413210FB3EA5CD78
:1032700041321823E5210332220E4206401600CDCA
:1032800020327AB720F510F7CD20327AFEA520F84B
:10329000212A2A223E3C7CE1C1D1C9E521BA322251
:1032A0000C4206003E55CDB43210F93E7FCDB4320B
:1032B0003EA518E3F5C5D54F1807F5C5D54FCD3E4A
:1032C000330608CD353310FB188ACD50330608CDB0
:1032D0005033CD7C3310F8C30A32E521CA32220EB6
:1032E000423E01D3E00680CD503379FE0F38F6FE22
:1032F0003E30F210F22100000640CD5033CD503365
:1033000051CD50337A913002ED44FE0D3805241032
:10331000E918032C10E43E40BC280ABD20D73E0229
:10332000D3E0CD50331600CD5033CD7C337AFE7FC1
:1033300020F5C39032CB0130051117121803112F5D
:103340002B1520FD3E02D3FF1D20FD3E01D3FFC9FA
:10335000FB0E000C3A4038E60428F8F321424B22D9
:103360003E3CC303421E0118021E003E06814FDB95
:10337000FFE601BB2003F1F1C9F1FBC979FE22CBC5
:1033800012FE0F3803FE3ED83E44323E3CC9CD60AB
:103390003020100180382118400AE6025FAE73A386
:1033A000C2BD303EFF214038CB662808CB25CB4636
:1033B00028023E1F32244201013821364016000AFD
:1033C0005FAE73A32032CD2031F2BF33CD3D31A6A5
:1033D0002008ED62220142C37D30E52A014223220A
:1033E0000142ED5BFF41ED52D1DAA130AF12220173
:1033F000422E9622FF4118AB5FC501C405CD600087
:10340000C10AA3C832FE417D32FD417A1717175712
:103410007B0F38031418FACD60303A80382002E66A
:1034200001E6032802CBF23A1940B72802CBFA2171
:1034300045305A1600197EFE1ACAA13047CD6030B9
:10344000782804B7CABD30212442FE2A20043E1F3A
:10345000BE78C3FD30ED56317D40D3E4F620D3EC89
:103460003E81D3F43ED0D3F0CD18353E04D3E03EB8
:103470000BD3F021AA36110040014C00EDB021F928
:103480003611E541014000EDB0CDC901CD8D02C23C
:10349000AF37DBF03CCAAF370100000B3E81D3F4FD
:1034A00078B1CAAF37DBF0CB5728F01E050100001A
:1034B000DBF0CB4F20110B3E81D3F478B120F1210A
:1034C0007702CD1B0218E41D20E33E81D3F42102D4
:1034D00035224A403EC33249403E80D3E401F300E6
:1034E0002100433E01D3F23E80D3F0CD1835DBF00E
:1034F000E602CAEE34EDA23E81F640D3F4EDA2C35B
:10350000F734AFD3E421ED45224940CD1835DBF047
:10351000E1E61CCA004318B2C5C100C9C24940DB7C
:10352000E4CB6F28FAC30000FF119135D5DBEC3AEC
:103530002240B728223A1C40B7201C211A403520CF
:10354000163607237EE601EE01772A204028053A49
:10355000234018023E207721164235C0361E231123
:1035600066020603341A96C077231310F723342318
:103570007E2B3D835F1ABED07EFE1E30062B7E233F
:10358000E603C8360123347ED60DD836012B2B3402
:10359000C93A1042CB47C83A1642FE1EC021353CFC
:1035A0001119420E3A06031A1B362F34D60A30FB85
:1035B000C63A23772305C8712318EC111C420E2F3D
:1035C00018E3F5DBE01FD265331FD26933C5D5E5BB
:1035D000DDE5FDE521F135E51FD246401FD23D4036
:1035E0001FD206421FD209421FD240401FD2434081
:1035F000E1FDE1DDE1E1D1C1F1FBC9F3DBEAFEFF71
:103600002838AFD3E8DD7E03D3E9DD7E04B7282A6E
:10361000D3EAFD21E541CD4436DD7E05B72804FD22
:10362000CB04CEFDCB04D6FD21ED41B72804FDCB64
:1036300004CEFDCB04D6DBE8FBC9AF06040EE8EDF3
:10364000790C10FB21E841060336002310FB21F022
:1036500041060336002310FB18DCDD21E541AFDD18
:103660007703DDCB0456C8DBEACB7F200DDDCB042E
:103670004EC8CD8D0228F0C30342DBEBDD7703C9D2
:10368000DD21ED41DDCB0456C8DBEACB77200DDD33
:10369000CB044EC8CD8D0228F0C30342DD7E03B7B4
:1036A000200179D3EBDD360300C9C3961CC3781D16
:1036B000C3901CC3D925C90000C90000C31830013C
:1036C00024300001070000077304003C00B000062E
:1036D000C203430100FF52C30050C70000AFC9003E
:1036E000AAAAAAAAAAAAAAC3FA35C3FA35C3FA355E
:1036F000C32935C70000000000011E300000005241
:1037000049022130000000524F021B30556CFF521D
:103710004E0000FFFF0000C32E02C3FA35C3FA3586
:103720004132033228033C0400001E000000000068
:103730000002393700000000FFDD7E03FE52200347
:10374000DD7E04CD5E37C0E5DD7E05FE522003DD63
:103750007E06CD5E37EBE1C0010300EDB0C9216C00
:1037600037010F00EDB1C07E23666FC94B15404491
:103770001D4050254049E5414FED41FE22200A3AC7
:103780009F40EE01329F403E22FE3AC2AA063A9F77
:10379000401FDAA80617C3A306D7E53E11CD572868
:1037A0002AD440CDBB35362023CDA035C38428CDC7
:1037B000B537C37500FBCDD73721F637CD1B02CD0A
:1037C0004900FE0D280EF5CD3300F1FE482805FE18
:1037D0004C20E2AF3211423E0DC333002130302283
:1037E0007741C32E02AAAAAAFFFF01CD1B02210224
:1037F00002CD1B0218E60E436173733F2003AAAA91
:00000001FF



================================================
FILE: src/assembler.js
================================================
/**
 * @fileoverview Z80 Assembler - Main orchestrator for the assembly process
 * 
 * This module provides the main Z80Assembler class that coordinates the
 * lexer, parser, and code generator to convert Z80 assembly source code
 * into executable machine code bytecode.
 * 
 * @module assembler
 * @requires ./lexer
 * @requires ./parser
 * @requires ./codegen
 * @requires ./constants
 */

import { Lexer } from './lexer.js';
import { Parser } from './parser.js';
import { CodeGenerator } from './codegen.js';
import { MEMORY } from './constants.js';

/**
 * @typedef {Object} AssemblyError
 * @property {string} message - Error message
 * @property {number} line - Line number where error occurred
 * @property {number} column - Column number where error occurred
 */

/**
 * @typedef {Object} AssemblyWarning
 * @property {string} message - Warning message
 * @property {number} line - Line number where warning occurred
 * @property {number} column - Column number where warning occurred
 */

/**
 * @typedef {Object} Symbol
 * @property {number} address - Address or value of the symbol
 * @property {string} type - Type of symbol ('LABEL', 'EQU', 'DEFL')
 */

/**
 * @typedef {Object} AssemblyResult
 * @property {boolean} success - Whether assembly succeeded without errors
 * @property {Uint8Array} bytes - Generated machine code bytes
 * @property {number} startAddress - Starting address of the program
 * @property {AssemblyError[]} errors - Array of errors encountered
 * @property {AssemblyWarning[]} warnings - Array of warnings generated
 * @property {Object.<string, Symbol>} symbolTable - Symbol table with label addresses
 * @property {Array} [instructions] - Generated instruction objects (if successful)
 */

/**
 * Z80 Assembler class - Converts Z80 assembly source code to machine code
 * 
 * This is the main entry point for the assembler. It orchestrates the
 * three-stage assembly process:
 * 1. Lexical analysis (tokenization)
 * 2. Parsing (two-pass symbol resolution)
 * 3. Code generation (bytecode emission)
 * 
 * @class
 * @example
 * const assembler = new Z80Assembler();
 * const result = assembler.assemble(`
 *   .ORG $4200
 *   START: LD A, 5
 *          HALT
 *   .END
 * `);
 * 
 * if (result.success) {
 *   console.log('Bytecode:', Array.from(result.bytes));
 *   console.log('Symbols:', result.symbolTable);
 * }
 */
export class Z80Assembler {
  /**
   * Creates a new Z80Assembler instance
   * Initializes error and warning arrays
   */
  constructor() {
    this.reset();
  }

  /**
   * Resets the assembler state
   * Clears all errors and warnings from previous assembly runs
   * 
   * @private
   */
  reset() {
    /** @type {AssemblyError[]} */
    this.errors = [];
    
    /** @type {AssemblyWarning[]} */
    this.warnings = [];
  }

  /**
   * Assembles Z80 source code into machine code
   * 
   * Performs a complete assembly process:
   * 1. Validates input
   * 2. Tokenizes source with Lexer
   * 3. Parses tokens with two-pass Parser
   * 4. Generates bytecode with CodeGenerator
   * 5. Returns comprehensive results
   * 
   * @param {string} source - Z80 assembly source code
   * @returns {AssemblyResult} Complete assembly result with bytecode and metadata
   * 
   * @example
   * const result = assembler.assemble('LD A, 5\\nHALT');
   * if (result.success) {
   *   console.log('Generated', result.bytes.length, 'bytes');
   * } else {
   *   result.errors.forEach(err => console.error(err.message));
   * }
   */
  assemble(source) {
    this.reset();

    if (typeof source !== 'string') {
      return this.failResult('Source must be a string');
    }

    if (source.trim().length === 0) {
      return this.failResult('Empty source');
    }

    try {
      const lexer = new Lexer(source);
      const tokens = lexer.tokenize();

      const lexerErrors = tokens.filter(t => t.type === 'ERROR');
      lexerErrors.forEach(e => {
        this.errors.push({
          message: `Unexpected character: ${e.value}`,
          line: e.line,
          column: e.column
        });
      });

      const parser = new Parser(tokens);
      const result = parser.parse();

      this.errors.push(...result.errors);
      this.warnings.push(...result.warnings);

      // Generate bytecode
      // Pass the symbol table by reference so codegen can update addresses
      const codegen = new CodeGenerator(result.symbolTable, result.startAddress);
      const instructions = codegen.generate(result.instructions);

      const bytes = this.assembleBytes(instructions);

      return {
        success: this.errors.length === 0,
        bytes: bytes,
        startAddress: result.startAddress,
        errors: this.errors,
        warnings: this.warnings,
        symbolTable: codegen.symbolTable, // Use updated symbol table from codegen
        instructions: instructions // Include generated instructions
      };

    } catch (e) {
      return this.failResult(`Internal assembler error: ${e.message}`);
    }
  }

  /**
   * Assembles instruction objects into a contiguous byte array
   * 
   * Takes the generated instruction objects from the code generator
   * and combines all their bytecode into a single Uint8Array suitable
   * for execution or output.
   * 
   * @private
   * @param {Array<Object>} instructions - Array of instruction objects with bytes property
   * @returns {Uint8Array} Combined bytecode array
   * 
   * @example
   * // instructions = [{bytes: [0x3E, 0x05]}, {bytes: [0x76]}]
   * // Returns: Uint8Array([0x3E, 0x05, 0x76])
   */
  assembleBytes(instructions) {
    // Calculate total size needed
    let totalSize = 0;
    instructions.forEach(inst => {
      totalSize += inst.bytes.length;
    });

    // Allocate byte array
    const bytes = new Uint8Array(totalSize);
    let offset = 0;

    // Copy all instruction bytes into the array
    instructions.forEach(inst => {
      for (const byte of inst.bytes) {
        bytes[offset++] = byte & 0xFF; // Ensure 8-bit values
      }
    });

    return bytes;
  }

  /**
   * Creates a failed assembly result
   * 
   * Used when assembly fails due to validation errors or internal errors.
   * Returns a standardized error result object.
   * 
   * @private
   * @param {string} message - Error message describing the failure
   * @returns {AssemblyResult} Failed assembly result with error
   * 
   * @example
   * return this.failResult('Source must be a string');
   */
  failResult(message) {
    return {
      success: false,
      bytes: new Uint8Array(0),
      startAddress: MEMORY.DEFAULT_ORG,
      errors: [{ message, line: 1, column: 1 }],
      warnings: [],
      symbolTable: {}
    };
  }
}




================================================
FILE: src/codegen.js
================================================
import {
  SIMPLE_INSTRUCTIONS,
  encodeLD,
  encodeJP,
  encodeJR,
  encodeDJNZ,
  encodeALU,
  encodeADDHL,
  encodeINC,
  encodeDEC,
  encodePUSH,
  encodePOP,
  encodeCALL,
  encodeRETCC,
  encodeRST,
  encodeCB,
  encodeIN,
  encodeOUT
} from './opcodes.js';
import { ExpressionEvaluator } from './evaluator.js';

export class CodeGenerator {
  constructor(symbolTable, currentAddress) {
    this.symbolTable = symbolTable;
    this.currentAddress = currentAddress;
  }

  /**
   * Generate bytecode for a list of instructions
   * @param {Array} instructions - Parsed instruction IR
   * @returns {Array} Array of instruction objects with bytes filled in
   */
  generate(instructions) {
    const result = [];
    let currentAddress = this.currentAddress;
    
    // First pass: generate all code and update addresses
    for (const inst of instructions) {
      if (inst.type === 'DATA') {
        inst.address = currentAddress;
        
        // Update symbol table if this data has an associated label
        // This happens at the correct address since we're tracking currentAddress correctly
        if (inst.label) {
          this.symbolTable[inst.label] = { address: currentAddress, type: 'LABEL' };
        }
        
        currentAddress += inst.bytes.length;
        result.push(inst);
        continue;
      }

      if (inst.type === 'INSTRUCTION') {
        // Update current address for this instruction
        this.currentAddress = currentAddress;
        inst.address = currentAddress;
        
        // Update symbol table if this instruction has an associated label
        if (inst.label) {
          this.symbolTable[inst.label] = { address: currentAddress, type: 'LABEL' };
        }
        
        // Generate encoding (this may reference labels that haven't been updated yet)
        try {
          const encoding = this.encodeInstruction(inst);
          inst.bytes = encoding.bytes;
          currentAddress += encoding.bytes.length;
          result.push(inst);
        } catch (e) {
          throw new Error(`Line ${inst.address}: ${e.message}`);
        }
      }
    }
    
    // Second pass: re-resolve any label references now that all addresses are correct
    // This is needed because some instructions may have referenced forward labels
    // that were defined later in the code
    for (const inst of result) {
      if (inst.type === 'INSTRUCTION') {
        // Check if operands contain label references that need re-resolution
        const needsReresolve = inst.operands && inst.operands.some(op => 
          op && typeof op === 'object' && op.type === 'LABEL_REF'
        );
        
        if (needsReresolve) {
          // Re-encode with updated symbol table (all labels should now have correct addresses)
          try {
            this.currentAddress = inst.address;
            const encoding = this.encodeInstruction(inst);
            inst.bytes = encoding.bytes;
          } catch (e) {
            // If re-encoding fails, the original encoding should still work
            // (labels should have been resolved in first pass)
            console.warn(`Warning: Failed to re-encode instruction at ${inst.address.toString(16)}: ${e.message}`);
          }
        }
      }
    }

    return result;
  }

  encodeInstruction(inst) {
    const { mnemonic, operands } = inst;

    // Simple instructions with no operands
    if (SIMPLE_INSTRUCTIONS[mnemonic]) {
      const def = SIMPLE_INSTRUCTIONS[mnemonic];
      if (def.prefix !== undefined) {
        return {
          bytes: [def.prefix, def.opcode],
          size: def.size
        };
      }
      return {
        bytes: [def.opcode],
        size: def.size
      };
    }

    // LD instruction
    if (mnemonic === 'LD') {
      // Update currentAddress for operand resolution
      const savedAddr = this.currentAddress;
      this.currentAddress = inst.address;
      const resolved = this.resolveOperands(operands, inst.address);
      this.currentAddress = savedAddr;
      return encodeLD(resolved);
    }

    // JP instruction
    if (mnemonic === 'JP') {
      const resolved = this.resolveOperands(operands, inst.address);
      return encodeJP(resolved);
    }

    // JR instruction
    if (mnemonic === 'JR') {
      const savedAddr = this.currentAddress;
      this.currentAddress = inst.address;
      const resolved = this.resolveOperands(operands, inst.address);
      this.currentAddress = savedAddr;
      // For relative jumps, calculate offset from instruction end
      if (resolved.length === 1 && typeof resolved[0] === 'number') {
        // Calculate relative offset: target - (current + 2)
        const target = resolved[0];
        const current = inst.address;
        const offset = target - (current + 2);
        // Clamp to signed 8-bit
        if (offset < -128 || offset > 127) {
          throw new Error(`Relative jump out of range: ${offset} (must be -128 to 127)`);
        }
        return encodeJR([offset]);
      }
      if (resolved.length === 2 && typeof resolved[1] === 'number') {
        const target = resolved[1];
        const current = inst.address;
        const offset = target - (current + 2);
        if (offset < -128 || offset > 127) {
          throw new Error(`Relative jump out of range: ${offset} (must be -128 to 127)`);
        }
        return encodeJR([resolved[0], offset]);
      }
      return encodeJR(resolved);
    }

    // DJNZ instruction
    if (mnemonic === 'DJNZ') {
      const savedAddr = this.currentAddress;
      this.currentAddress = inst.address;
      const resolved = this.resolveOperands(operands, inst.address);
      this.currentAddress = savedAddr;
      // Calculate relative offset
      if (typeof resolved[0] === 'number') {
        const target = resolved[0];
        const current = inst.address;
        const offset = target - (current + 2);
        if (offset < -128 || offset > 127) {
          throw new Error(`Relative jump out of range: ${offset} (must be -128 to 127)`);
        }
        return encodeDJNZ(offset);
      }
      return encodeDJNZ(resolved[0]);
    }

    // ADD HL,ss - special case for 16-bit addition
    if (mnemonic === 'ADD' && operands.length === 2 && operands[0] === 'HL') {
      const resolved = this.resolveOperands(operands, inst.address);
      return encodeADDHL(resolved);
    }

    // Arithmetic/Logic operations
    if (['ADD', 'ADC', 'SUB', 'SBC', 'AND', 'OR', 'XOR', 'CP'].includes(mnemonic)) {
      const savedAddr = this.currentAddress;
      this.currentAddress = inst.address;
      const resolved = this.resolveOperands(operands, inst.address);
      this.currentAddress = savedAddr;
      return encodeALU(mnemonic, resolved);
    }

    // INC instruction
    if (mnemonic === 'INC') {
      const resolved = this.resolveOperands(operands, inst.address);
      return encodeINC(resolved[0]);
    }

    // DEC instruction
    if (mnemonic === 'DEC') {
      const resolved = this.resolveOperands(operands, inst.address);
      return encodeDEC(resolved[0]);
    }

    // PUSH instruction
    if (mnemonic === 'PUSH') {
      const resolved = this.resolveOperands(operands, inst.address);
      return encodePUSH(resolved[0]);
    }

    // POP instruction
    if (mnemonic === 'POP') {
      const resolved = this.resolveOperands(operands, inst.address);
      return encodePOP(resolved[0]);
    }

    // CALL instruction
    if (mnemonic === 'CALL') {
      const resolved = this.resolveOperands(operands, inst.address);
      return encodeCALL(resolved);
    }

    // RET cc instruction
    if (mnemonic === 'RET') {
      if (operands.length === 0) {
        return { bytes: [0xC9], size: 1 };
      }
      const resolved = this.resolveOperands(operands, inst.address);
      return encodeRETCC(resolved[0]);
    }

    // RST instruction
    if (mnemonic === 'RST') {
      const resolved = this.resolveOperands(operands, inst.address);
      return encodeRST(resolved[0]);
    }

    // CB-prefixed instructions
    if (['RLC', 'RRC', 'RL', 'RR', 'SLA', 'SRA', 'SLL', 'SRL', 'BIT', 'SET', 'RES'].includes(mnemonic)) {
      const resolved = this.resolveOperands(operands, inst.address);
      return encodeCB(mnemonic, resolved);
    }

    // IN instruction
    if (mnemonic === 'IN') {
      const resolved = this.resolveOperands(operands, inst.address);
      return encodeIN(resolved);
    }

    // OUT instruction
    if (mnemonic === 'OUT') {
      const resolved = this.resolveOperands(operands, inst.address);
      return encodeOUT(resolved);
    }

    throw new Error(`Unsupported instruction: ${mnemonic}`);
  }

  resolveOperands(operands, currentAddr) {
    return operands.map(op => {
      // Handle label references that were stored as objects in pass 2
      // These need to be resolved to addresses using the current symbol table
      if (op && typeof op === 'object' && op.type === 'LABEL_REF') {
        const symbol = this.symbolTable[op.name];
        if (symbol) {
          // Return the address from the symbol table
          return symbol.address;
        }
        throw new Error(`Undefined symbol: ${op.name}`);
      }
      
      if (typeof op === 'number') {
        return op;
      }
      if (typeof op === 'string') {
        // Check if it's a register or condition code
        if (['A', 'B', 'C', 'D', 'E', 'H', 'L', '(HL)', '(BC)', '(DE)'].includes(op)) {
          return op;
        }
        if (['NZ', 'Z', 'NC', 'C', 'PO', 'PE', 'P', 'M'].includes(op)) {
          return op;
        }
        if (['BC', 'DE', 'HL', 'SP', 'AF'].includes(op)) {
          return op;
        }
        // Try to resolve as label - use current symbol table
        const symbol = this.symbolTable[op];
        if (symbol) {
          return symbol.address;
        }
        // If not found, might be a forward reference that wasn't resolved
        // This shouldn't happen in pass 2, but handle gracefully
        throw new Error(`Undefined symbol: ${op}`);
      }
      return op;
    });
  }
}




================================================
FILE: src/constants.js
================================================
/**
 * @fileoverview Constants and enumerations for Z80 assembler
 * 
 * Defines all token types, register encodings, condition codes,
 * memory maps, mnemonics, and directives used throughout the assembler.
 * 
 * @module constants
 */

/**
 * Token type enumeration
 * 
 * Defines all possible token types that the lexer can produce.
 * Used throughout the parser to identify and process different
 * elements of assembly source code.
 * 
 * @enum {string}
 * @readonly
 */
export const TOKEN = {
  /** Identifier (potential label or constant reference) */
  LABEL:      'LABEL',
  
  /** Z80 instruction mnemonic (LD, ADD, etc.) */
  MNEMONIC:   'MNEMONIC',
  
  /** Z80 register name (A, B, HL, etc.) */
  REGISTER:   'REGISTER',
  
  /** Numeric literal (decimal, hex, binary) */
  NUMBER:     'NUMBER',
  
  /** String literal in quotes */
  STRING:     'STRING',
  
  /** Assembler directive (.ORG, .DB, etc.) */
  DIRECTIVE:  'DIRECTIVE',
  
  /** Arithmetic or logical operator (+, -, *, etc.) */
  OPERATOR:   'OPERATOR',
  
  /** Left parenthesis ( */
  LPAREN:     'LPAREN',
  
  /** Right parenthesis ) */
  RPAREN:     'RPAREN',
  
  /** Comma separator */
  COMMA:      'COMMA',
  
  /** Colon (label definition) */
  COLON:      'COLON',
  
  /** End of line */
  NEWLINE:    'NEWLINE',
  
  /** End of file */
  EOF:        'EOF',
  
  /** Comment text (ignored during assembly) */
  COMMENT:    'COMMENT'
};

/**
 * Z80 8-bit register encoding
 * 
 * Maps register names to their 3-bit encoding values used in
 * most Z80 instructions. The encoding follows the Z80 instruction
 * set specification.
 * 
 * @type {Object.<string, number>}
 * @readonly
 * 
 * @example
 * // LD A, B encodes as: 01 111 000 where 111=A, 000=B
 * const destEncoding = REG8['A']; // 7
 * const srcEncoding = REG8['B'];  // 0
 */
export const REG8 = {
  'B': 0,      // 000
  'C': 1,      // 001
  'D': 2,      // 010
  'E': 3,      // 011
  'H': 4,      // 100
  'L': 5,      // 101
  '(HL)': 6,   // 110 - indirect through HL
  'A': 7       // 111 - accumulator
};

/**
 * Z80 16-bit register pair encoding
 * 
 * Maps 16-bit register pair names to their 2-bit encoding values.
 * Used in instructions like LD dd,nn, ADD HL,ss, etc.
 * 
 * @type {Object.<string, number>}
 * @readonly
 * 
 * @example
 * // LD HL, 1234h encodes as: 00 10 0001 nnnn nnnn
 * const regEncoding = REG16['HL']; // 2
 */
export const REG16 = {
  'BC': 0,  // 00 - register pair B and C
  'DE': 1,  // 01 - register pair D and E
  'HL': 2,  // 10 - register pair H and L
  'SP': 3   // 11 - stack pointer
};

/**
 * Stack operation register pair encoding
 * 
 * Similar to REG16 but uses AF (accumulator + flags) instead of SP.
 * Used specifically for PUSH and POP instructions.
 * 
 * @type {Object.<string, number>}
 * @readonly
 * 
 * @example
 * // PUSH AF encodes as: 11 11 0101
 * const regEncoding = STACK_REG['AF']; // 3
 */
export const STACK_REG = {
  'BC': 0,  // 00 - B and C registers
  'DE': 1,  // 01 - D and E registers
  'HL': 2,  // 10 - H and L registers
  'AF': 3   // 11 - accumulator and flags
};

/**
 * Z80 condition code encoding
 * 
 * Maps condition code mnemonics to their 3-bit encoding values.
 * Used in conditional jumps, calls, and returns.
 * 
 * @type {Object.<string, number>}
 * @readonly
 * 
 * @example
 * // JP NZ, label encodes as: 11 000 010
 * const condEncoding = CONDITIONS['NZ']; // 0
 */
export const CONDITIONS = {
  'NZ': 0,  // 000 - not zero
  'Z':  1,  // 001 - zero
  'NC': 2,  // 010 - no carry
  'C':  3,  // 011 - carry
  'PO': 4,  // 100 - parity odd
  'PE': 5,  // 101 - parity even
  'P':  6,  // 110 - positive (sign flag clear)
  'M':  7   // 111 - minus (sign flag set)
};

/**
 * TRS-80 Model III memory map
 * 
 * Defines the complete memory layout specific to the TRS-80 Model III
 * computer. This configuration determines where ROM, keyboard I/O,
 * video RAM, and user RAM are located in the 64KB address space.
 * 
 * Memory Layout:
 * - $0000-$37FF: 14KB ROM (Level II BASIC interpreter)
 * - $3800-$3BFF: 1KB memory-mapped keyboard matrix
 * - $3C00-$3FFF: 1KB video RAM (64√ó16 character display)
 * - $4000-$7FFF: 16KB user RAM (base configuration)
 * - $4200: Default program start address
 * 
 * @type {Object}
 * @readonly
 * 
 * @property {number} ROM_START - ROM begins at $0000
 * @property {number} ROM_END - ROM ends at $37FF (14KB)
 * @property {number} KEYBOARD_START - Keyboard matrix at $3800
 * @property {number} KEYBOARD_END - Keyboard ends at $3BFF (1KB)
 * @property {number} VIDEO_START - Video RAM at $3C00
 * @property {number} VIDEO_END - Video RAM ends at $3FFF (1KB, 1024 characters)
 * @property {number} RAM_START - User RAM begins at $4000
 * @property {number} RAM_END - User RAM ends at $7FFF (16KB base)
 * @property {number} DEFAULT_ORG - Default program origin at $4200
 * 
 * @example
 * // Initialize video RAM
 * .ORG $4200
 * LD HL, MEMORY.VIDEO_START  ; Point to screen
 * LD (HL), $20               ; Write space character
 */
export const MEMORY = {
  ROM_START:       0x0000,    // ROM begins
  ROM_END:         0x37FF,    // 14KB ROM
  KEYBOARD_START:  0x3800,    // Keyboard matrix
  KEYBOARD_END:    0x3BFF,    // 1KB keyboard area
  VIDEO_START:     0x3C00,    // Video RAM begins
  VIDEO_END:       0x3FFF,    // 1KB video (64√ó16 = 1024 bytes)
  RAM_START:       0x4000,    // User RAM begins
  RAM_END:         0x7FFF,    // 16KB user RAM (expandable)
  DEFAULT_ORG:     0x4200     // Standard program start
};

/**
 * Z80 instruction mnemonics
 * 
 * Complete set of all valid Z80 instruction mnemonics.
 * Used by the lexer to identify instruction tokens vs. labels.
 * Includes all standard Z80 instructions including undocumented ones.
 * 
 * @type {Set<string>}
 * @readonly
 * 
 * @example
 * if (MNEMONICS.has(token.toUpperCase())) {
 *   return { type: TOKEN.MNEMONIC, value: token };
 * }
 */
export const MNEMONICS = new Set([
  // Arithmetic
  'ADC', 'ADD', 'SBC', 'SUB', 'INC', 'DEC', 'NEG', 'DAA', 'CPL',
  
  // Logical
  'AND', 'OR', 'XOR', 'CP',
  
  // Rotate and shift
  'RLCA', 'RLA', 'RRCA', 'RRA', 'RLC', 'RL', 'RRC', 'RR',
  'SLA', 'SRA', 'SLL', 'SRL', 'RLD', 'RRD',
  
  // Bit operations
  'BIT', 'SET', 'RES',
  
  // Jump and call
  'JP', 'JR', 'DJNZ', 'CALL', 'RET', 'RETI', 'RETN', 'RST',
  
  // Load
  'LD', 'PUSH', 'POP', 'EX', 'EXX',
  
  // Block operations
  'LDI', 'LDIR', 'LDD', 'LDDR',
  'CPI', 'CPIR', 'CPD', 'CPDR',
  'INI', 'INIR', 'IND', 'INDR',
  'OUTI', 'OTIR', 'OUTD', 'OTDR',
  
  // I/O
  'IN', 'OUT',
  
  // Control
  'NOP', 'HALT', 'DI', 'EI', 'IM', 'SCF', 'CCF'
]);

/**
 * Z80 register names
 * 
 * Complete set of all valid Z80 register names including 8-bit,
 * 16-bit, index registers, and special registers.
 * Used by the lexer to identify register tokens.
 * 
 * @type {Set<string>}
 * @readonly
 * 
 * @example
 * if (REGISTERS.has(token.toUpperCase())) {
 *   return { type: TOKEN.REGISTER, value: token };
 * }
 */
export const REGISTERS = new Set([
  // 8-bit registers
  'A', 'B', 'C', 'D', 'E', 'H', 'L',
  
  // 16-bit register pairs
  'AF', 'BC', 'DE', 'HL', 'SP', 'PC',
  
  // Index registers
  'IX', 'IY',
  
  // Index register halves (undocumented)
  'IXH', 'IXL', 'IYH', 'IYL',
  
  // Special registers
  'I',    // Interrupt vector
  'R',    // Memory refresh
  "AF'"   // Alternate AF register pair
]);

/**
 * Assembler directives
 * 
 * Set of all valid assembler directives that control assembly behavior.
 * Includes both dotted (.ORG) and non-dotted (ORG) forms, plus common
 * aliases used in various assemblers.
 * 
 * Supported directives:
 * - .ORG/.org: Set origin address
 * - .DB/.db/DEFB: Define byte(s)
 * - .DW/.dw/DEFW: Define word(s) - 16-bit little-endian
 * - .DS/.ds/DEFS: Define space - reserve bytes
 * - .EQU/.equ: Define constant (immutable)
 * - .DEFL/.defl: Define label (mutable)
 * - .END/.end: End of source (optional)
 * 
 * @type {Set<string>}
 * @readonly
 * 
 * @example
 * if (DIRECTIVES.has(token.toUpperCase())) {
 *   return { type: TOKEN.DIRECTIVE, value: token };
 * }
 */
export const DIRECTIVES = new Set([
  // Standard forms with dot prefix
  '.ORG', '.DB', '.DW', '.EQU', '.DEFL', '.END', '.DS',
  
  // Forms without dot prefix
  'ORG', 'DB', 'DW', 'EQU', 'DEFL', 'END', 'DS',
  
  // Common aliases
  'DEFB',  // Define byte (same as .DB)
  'DEFW',  // Define word (same as .DW)
  'DEFM',  // Define message (same as .DB with string)
  'DEFS'   // Define space (same as .DS)
]);




================================================
FILE: src/evaluator.js
================================================
/**
 * @fileoverview Expression evaluator for assembly-time arithmetic
 * 
 * Implements a recursive descent parser that evaluates arithmetic expressions
 * in Z80 assembly source code. Supports standard operators, parentheses,
 * label references, and the current address symbol ($).
 * 
 * Grammar (operator precedence):
 * ```
 * expression  := additive
 * additive    := multiplicative (('+' | '-') multiplicative)*
 * multiplicative := unary (('*' | '/') unary)*
 * unary       := '-' unary | '+' unary | primary
 * primary     := NUMBER | LABEL | '$' | '(' expression ')'
 * ```
 * 
 * Supported operators:
 * - Arithmetic: +, -, *, / (integer division)
 * - Grouping: ( )
 * - Special: $ (current program counter)
 * - Labels: Resolved to their addresses
 * 
 * Expression examples:
 * - `OFFSET + 10` - Add 10 to label address
 * - `$ + 5` - Current address plus 5
 * - `(100 * 2) + LABEL` - Complex expression
 * - `VIDEO_RAM + (64 * row)` - Calculate screen position
 * 
 * @module evaluator
 */

/**
 * @typedef {Object} ParseResult
 * @property {number} value - The evaluated numeric value
 * @property {number} pos - Position in token array after parsing
 */

/**
 * Expression evaluator class
 * 
 * Evaluates arithmetic expressions using recursive descent parsing with
 * proper operator precedence. Resolves label references and special
 * symbols like $ (current address) before evaluation.
 * 
 * The evaluator is stateful, maintaining references to:
 * - Symbol table (for label lookups)
 * - Current address (for $ substitution)
 * 
 * @class
 * @example
 * const evaluator = new ExpressionEvaluator(symbolTable, 0x4200);
 * const tokens = [{type: 'NUMBER', value: 10}, ...];
 * const result = evaluator.evaluate(tokens);  // Returns numeric value
 */
export class ExpressionEvaluator {
  /**
   * Creates a new expression evaluator
   * 
   * @param {Object.<string, {address: number}>} symbolTable - Symbol table for label lookups
   * @param {number} currentAddress - Current assembly address (for $ substitution)
   */
  constructor(symbolTable, currentAddress) {
    /** @type {Object.<string, {address: number}>} */
    this.symbolTable = symbolTable;
    
    /** @type {number} */
    this.currentAddress = currentAddress;
  }

  /**
   * Evaluates an expression from an array of tokens
   * 
   * Main entry point for expression evaluation. Preprocesses tokens to:
   * 1. Remove whitespace and comments
   * 2. Substitute $ with current address
   * 3. Resolve label references to addresses
   * 
   * Then parses the processed tokens using recursive descent.
   * 
   * @param {Array<Object>} tokens - Array of tokens representing the expression
   * @returns {number} Evaluated numeric value (integer)
   * @throws {Error} If expression is empty, has syntax errors, or references undefined symbols
   * 
   * @example
   * // Simple addition
   * evaluate([
   *   {type: 'NUMBER', value: 10},
   *   {type: 'OPERATOR', value: '+'},
   *   {type: 'NUMBER', value: 5}
   * ]);  // Returns: 15
   * 
   * @example
   * // Label reference
   * evaluate([
   *   {type: 'LABEL', value: 'START'},
   *   {type: 'OPERATOR', value: '+'},
   *   {type: 'NUMBER', value: 10}
   * ]);  // Returns: (address of START) + 10
   */
  evaluate(tokens) {
    if (!tokens || tokens.length === 0) {
      throw new Error('Empty expression');
    }

    // Remove whitespace tokens and handle $ (current address)
    const processed = this.preprocess(tokens);
    
    if (processed.length === 0) {
      throw new Error('Empty expression after preprocessing');
    }

    // Parse using recursive descent
    return this.parseExpression(processed, 0).value;
  }

  /**
   * Preprocesses tokens before evaluation
   * 
   * Transforms tokens by:
   * 1. Removing whitespace, newlines, and comments
   * 2. Substituting $ with the current address value
   * 3. Resolving label references to their numeric addresses
   * 
   * This simplifies the parser by ensuring all operands are numbers.
   * 
   * @private
   * @param {Array<Object>} tokens - Raw token array
   * @returns {Array<Object>} Processed tokens with $ and labels resolved
   * @throws {Error} If an undefined symbol is referenced
   * 
   * @example
   * // Input:  [{type: 'LABEL', value: 'START'}, {type: 'OPERATOR', value: '$'}]
   * // Output: [{type: 'NUMBER', value: 0x4200}, {type: 'NUMBER', value: 0x4205}]
   */
  preprocess(tokens) {
    const result = [];
    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      
      // Skip whitespace, newlines, comments
      if (token.type === 'NEWLINE' || token.type === 'COMMENT') {
        continue;
      }

      // Handle $ (current address) - substitute with numeric value
      if (token.type === 'OPERATOR' && token.value === '$') {
        result.push({
          type: 'NUMBER',
          value: this.currentAddress,
          line: token.line,
          column: token.column
        });
        continue;
      }

      // Handle label references - look up in symbol table
      if (token.type === 'LABEL') {
        const symbol = this.symbolTable[token.value];
        if (symbol === undefined) {
          throw new Error(`Undefined symbol: ${token.value} at line ${token.line}`);
        }
        result.push({
          type: 'NUMBER',
          value: symbol.address,
          line: token.line,
          column: token.column
        });
        continue;
      }

      // Keep all other tokens as-is
      result.push(token);
    }
    return result;
  }

  /**
   * Parses a complete expression
   * 
   * Entry point for recursive descent parsing. Delegates to
   * parseAdditive which handles the lowest precedence operators.
   * 
   * @private
   * @param {Array<Object>} tokens - Preprocessed token array
   * @param {number} start - Starting position in token array
   * @returns {ParseResult} Parsed value and final position
   */
  parseExpression(tokens, start) {
    return this.parseAdditive(tokens, start);
  }

  /**
   * Parses additive expressions (+ and -)
   * 
   * Handles addition and subtraction with left-to-right associativity.
   * Lowest precedence level in the grammar.
   * 
   * Grammar: additive := multiplicative (('+' | '-') multiplicative)*
   * 
   * @private
   * @param {Array<Object>} tokens - Token array
   * @param {number} start - Starting position
   * @returns {ParseResult} Parsed value and final position
   * 
   * @example
   * // Parses: 10 + 20 - 5
   * // Result: {value: 25, pos: 5}
   */
  parseAdditive(tokens, start) {
    let left = this.parseMultiplicative(tokens, start);
    let pos = left.pos;

    while (pos < tokens.length) {
      const token = tokens[pos];
      if (token.type === 'OPERATOR' && (token.value === '+' || token.value === '-')) {
        const op = token.value;
        const right = this.parseMultiplicative(tokens, pos + 1);
        if (op === '+') {
          left.value = left.value + right.value;
        } else {
          left.value = left.value - right.value;
        }
        pos = right.pos;
      } else {
        break;
      }
    }

    return { value: left.value, pos };
  }

  /**
   * Parses multiplicative expressions (* and /)
   * 
   * Handles multiplication and division with left-to-right associativity.
   * Higher precedence than addition/subtraction.
   * Division is integer division (truncates toward zero).
   * 
   * Grammar: multiplicative := unary (('*' | '/') unary)*
   * 
   * @private
   * @param {Array<Object>} tokens - Token array
   * @param {number} start - Starting position
   * @returns {ParseResult} Parsed value and final position
   * @throws {Error} If division by zero is attempted
   * 
   * @example
   * // Parses: 10 * 3 / 2
   * // Result: {value: 15, pos: 5}
   */
  parseMultiplicative(tokens, start) {
    let left = this.parseUnary(tokens, start);
    let pos = left.pos;

    while (pos < tokens.length) {
      const token = tokens[pos];
      if (token.type === 'OPERATOR' && (token.value === '*' || token.value === '/')) {
        const op = token.value;
        const right = this.parseUnary(tokens, pos + 1);
        if (op === '*') {
          left.value = left.value * right.value;
        } else {
          // Integer division with zero check
          if (right.value === 0) {
            throw new Error(`Division by zero at line ${tokens[pos].line}`);
          }
          left.value = Math.floor(left.value / right.value);
        }
        pos = right.pos;
      } else {
        break;
      }
    }

    return { value: left.value, pos };
  }

  /**
   * Parses unary expressions and primary values
   * 
   * Handles:
   * - Unary minus: -expr
   * - Unary plus: +expr (no-op)
   * - Parenthesized expressions: (expr)
   * - Primary values: numbers
   * 
   * Highest precedence level in the grammar.
   * 
   * Grammar: unary := ('-' | '+') unary | primary
   *         primary := NUMBER | '(' expression ')'
   * 
   * @private
   * @param {Array<Object>} tokens - Token array
   * @param {number} start - Starting position
   * @returns {ParseResult} Parsed value and final position
   * @throws {Error} If unexpected token or unmatched parenthesis
   * 
   * @example
   * // Parses: -(10 + 5)
   * // Result: {value: -15, pos: 5}
   */
  parseUnary(tokens, start) {
    if (start >= tokens.length) {
      throw new Error('Unexpected end of expression');
    }

    const token = tokens[start];

    // Unary minus
    if (token.type === 'OPERATOR' && token.value === '-') {
      const right = this.parseUnary(tokens, start + 1);
      return { value: -right.value, pos: right.pos };
    }

    // Unary plus (no-op)
    if (token.type === 'OPERATOR' && token.value === '+') {
      return this.parseUnary(tokens, start + 1);
    }

    // Parentheses
    if (token.type === 'LPAREN') {
      const expr = this.parseExpression(tokens, start + 1);
      if (expr.pos >= tokens.length || tokens[expr.pos].type !== 'RPAREN') {
        throw new Error(`Unmatched parenthesis at line ${token.line}`);
      }
      return { value: expr.value, pos: expr.pos + 1 };
    }

    // Number or identifier (already resolved in preprocess)
    if (token.type === 'NUMBER') {
      return { value: token.value, pos: start + 1 };
    }

    throw new Error(`Unexpected token: ${token.type} at line ${token.line}`);
  }
}




================================================
FILE: src/lexer.js
================================================
import { TOKEN, MNEMONICS, REGISTERS, DIRECTIVES } from './constants.js';

export class Lexer {
  constructor(source) {
    this.source = source;
    this.pos = 0;
    this.line = 1;
    this.column = 1;
    this.tokens = [];
  }

  /**
   * Main entry point - tokenize entire source
   * @returns {Array} Array of token objects
   */
  tokenize() {
    while (!this.isAtEnd()) {
      this.scanToken();
    }
    this.tokens.push(this.makeToken(TOKEN.EOF, ''));
    return this.tokens;
  }

  scanToken() {
    this.skipWhitespace();
    if (this.isAtEnd()) return;

    const char = this.peek();

    // Comments
    if (char === ';') {
      this.scanComment();
      return;
    }

    // Newlines (significant in assembly)
    if (char === '\n') {
      this.tokens.push(this.makeToken(TOKEN.NEWLINE, '\\n'));
      this.advance();
      this.line++;
      this.column = 1;
      return;
    }

    // Numbers: $hex, 0xhex, %binary, decimal, or decimalH
    // Check if $ is followed by hex digit (then it's $hex), otherwise it's current address operator
    if (this.isDigit(char) || char === '%') {
      this.scanNumber();
      return;
    }
    
    // Handle $hex format for numbers (must be followed by hex digit)
    if (char === '$') {
      const next = this.peekNext();
      if (next && this.isHexDigit(next)) {
        this.scanNumber();
        return;
      }
      // Standalone $ is current address operator
      this.tokens.push(this.makeToken(TOKEN.OPERATOR, '$'));
      this.advance();
      return;
    }

    // Strings
    if (char === '"' || char === "'") {
      this.scanString(char);
      return;
    }

    // Identifiers (labels, mnemonics, registers, directives)
    if (this.isAlpha(char) || char === '_' || char === '.') {
      this.scanIdentifier();
      return;
    }

    // Single-character tokens
    const singleChars = {
      '(': TOKEN.LPAREN,
      ')': TOKEN.RPAREN,
      ',': TOKEN.COMMA,
      ':': TOKEN.COLON,
      '+': TOKEN.OPERATOR,
      '-': TOKEN.OPERATOR,
      '*': TOKEN.OPERATOR,
      '/': TOKEN.OPERATOR,
      '$': TOKEN.OPERATOR  // Current address
    };

    if (singleChars[char]) {
      this.tokens.push(this.makeToken(singleChars[char], char));
      this.advance();
      return;
    }

    // Unknown character - record error but continue
    this.tokens.push(this.makeToken('ERROR', char));
    this.advance();
  }

  scanNumber() {
    const startCol = this.column;
    let value = '';

    if (this.peek() === '$') {
      // Hex: $FF
      this.advance();
      while (this.isHexDigit(this.peek())) {
        value += this.advance();
      }
      this.tokens.push({
        type: TOKEN.NUMBER,
        value: parseInt(value, 16),
        raw: '$' + value,
        line: this.line,
        column: startCol
      });
    } else if (this.peek() === '%') {
      // Binary: %10101010
      this.advance();
      while (this.peek() === '0' || this.peek() === '1') {
        value += this.advance();
      }
      this.tokens.push({
        type: TOKEN.NUMBER,
        value: parseInt(value, 2),
        raw: '%' + value,
        line: this.line,
        column: startCol
      });
    } else {
      // Decimal or hex with H suffix
      while (this.isHexDigit(this.peek())) {
        value += this.advance();
      }
      if (this.peek()?.toUpperCase() === 'H') {
        this.advance();
        this.tokens.push({
          type: TOKEN.NUMBER,
          value: parseInt(value, 16),
          raw: value + 'H',
          line: this.line,
          column: startCol
        });
      } else {
        this.tokens.push({
          type: TOKEN.NUMBER,
          value: parseInt(value, 10),
          raw: value,
          line: this.line,
          column: startCol
        });
      }
    }
  }

  scanIdentifier() {
    const startCol = this.column;
    let value = '';

    while (this.isAlphaNumeric(this.peek()) || this.peek() === '_' || this.peek() === '.') {
      value += this.advance();
    }

    // Check for AF' special case
    if (value.toUpperCase() === 'AF' && this.peek() === "'") {
      value += this.advance();
    }

    const upper = value.toUpperCase();

    // Classify the identifier
    let type;
    if (MNEMONICS.has(upper)) {
      type = TOKEN.MNEMONIC;
    } else if (REGISTERS.has(upper)) {
      type = TOKEN.REGISTER;
    } else if (DIRECTIVES.has(upper)) {
      type = TOKEN.DIRECTIVE;
    } else {
      type = TOKEN.LABEL;
    }

    this.tokens.push({
      type: type,
      value: upper,
      raw: value,
      line: this.line,
      column: startCol
    });
  }

  scanComment() {
    const startCol = this.column;
    let value = '';
    this.advance(); // skip ;
    while (!this.isAtEnd() && this.peek() !== '\n') {
      value += this.advance();
    }
    // Comments can be discarded or kept for debugging
    this.tokens.push({
      type: TOKEN.COMMENT,
      value: value.trim(),
      line: this.line,
      column: startCol
    });
  }

  scanString(quote) {
    const startCol = this.column;
    let value = '';
    this.advance(); // skip opening quote
    while (!this.isAtEnd() && this.peek() !== quote && this.peek() !== '\n') {
      value += this.advance();
    }
    if (this.peek() === quote) {
      this.advance(); // skip closing quote
    }
    this.tokens.push({
      type: TOKEN.STRING,
      value: value,
      line: this.line,
      column: startCol
    });
  }

  // Helper methods
  makeToken(type, value) {
    return { type, value, line: this.line, column: this.column };
  }

  peek() {
    return this.source[this.pos];
  }

  peekNext() {
    return this.source[this.pos + 1];
  }

  advance() {
    const char = this.source[this.pos++];
    this.column++;
    return char;
  }

  isAtEnd() {
    return this.pos >= this.source.length;
  }

  skipWhitespace() {
    while (!this.isAtEnd() && (this.peek() === ' ' || this.peek() === '\t' || this.peek() === '\r')) {
      this.advance();
    }
  }

  isDigit(c) { return c >= '0' && c <= '9'; }
  isHexDigit(c) { return this.isDigit(c) || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'); }
  isAlpha(c) { return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'); }
  isAlphaNumeric(c) { return this.isAlpha(c) || this.isDigit(c); }
}




================================================
FILE: src/main.js
================================================
/**
 * @fileoverview Main UI initialization and event handling
 * 
 * This is the main entry point for the browser-based Z80 assembler UI.
 * It initializes the assembler, sets up DOM element references, wires up
 * event handlers, and manages the interaction between the user interface
 * and the assembler core.
 * 
 * Features:
 * - Source code editor with keyboard shortcuts
 * - One-click assembly with results display
 * - TRS-80 DEBUG-style memory dump output
 * - Symbol table display
 * - Error and warning reporting
 * - Example program loader
 * - Status notifications
 * 
 * @module main
 * @requires ./assembler
 * @requires ./utils/formatter
 * @requires ./ui/examples
 */

import { Z80Assembler } from './assembler.js';
import { formatMemoryDump, formatSymbolTable, formatErrors, formatWarnings, formatBytes } from './utils/formatter.js';
import { initExamplesDropdown, getExampleById } from './ui/examples.js';

/**
 * Main assembler instance
 * Shared across all assembly operations
 * @type {Z80Assembler}
 */
const assembler = new Z80Assembler();

/**
 * DOM element references
 * Cached at startup for performance
 */
const sourceEditor = document.getElementById('source-editor');     // Textarea for source code
const outputDump = document.getElementById('output-dump');         // Memory dump display
const symbolTable = document.getElementById('symbol-table');       // Symbol table display
const errorsDisplay = document.getElementById('errors');           // Error messages
const warningsDisplay = document.getElementById('warnings');       // Warning messages
const assembleBtn = document.getElementById('assemble-btn');       // Assemble button
const exampleSelect = document.getElementById('example-select');   // Example dropdown
const statusDisplay = document.getElementById('status');           // Status bar
const charCounter = document.getElementById('char-counter');       // Character counter

// Character limit for source code (8000 chars - enough for complex programs)
const MAX_SOURCE_LENGTH = 8000;

/**
 * Assembles the current source code and updates the UI with results
 * 
 * Main assembly function that:
 * 1. Validates source code is present
 * 2. Invokes the assembler
 * 3. Displays formatted results (bytecode, symbols, errors)
 * 4. Updates status indicators
 * 
 * On success, displays:
 * - TRS-80 DEBUG-style memory dump
 * - Symbol table with addresses
 * - Any warnings generated
 * 
 * On failure, displays:
 * - Error messages with line/column numbers
 * - Any warnings generated
 * 
 * @private
 * @example
 * // Called when user clicks "Assemble" button or presses Ctrl+Enter
 * assemble();
 */
function assemble() {
  const source = sourceEditor.value;
  
  if (!source.trim()) {
    updateStatus('No source code to assemble', 'error');
    return;
  }

  updateStatus('Assembling...', 'info');
  
  const result = assembler.assemble(source);

  // Update output
  if (result.success) {
    updateStatus(`Success! Generated ${result.bytes.length} bytes`, 'success');
    
    // Memory dump
    outputDump.textContent = formatMemoryDump(result.bytes, result.startAddress);
    
    // Symbol table
    symbolTable.textContent = formatSymbolTable(result.symbolTable);
    
    // Errors (should be none)
    errorsDisplay.textContent = formatErrors(result.errors);
    
    // Warnings
    warningsDisplay.textContent = formatWarnings(result.warnings);
  } else {
    updateStatus(`Assembly failed: ${result.errors.length} error(s)`, 'error');
    
    // Show errors
    errorsDisplay.textContent = formatErrors(result.errors);
    warningsDisplay.textContent = formatWarnings(result.warnings);
    
    // Clear outputs
    outputDump.textContent = 'Assembly failed. See errors below.';
    symbolTable.textContent = 'No symbols (assembly failed)';
  }
}

/**
 * Updates the status display with a message and visual indicator
 * 
 * Changes the status bar text and applies appropriate CSS class for
 * visual feedback (info, success, error).
 * 
 * @private
 * @param {string} message - Status message to display
 * @param {'info'|'success'|'error'} [type='info'] - Status type for styling
 * 
 * @example
 * updateStatus('Assembling...', 'info');
 * updateStatus('Success! Generated 10 bytes', 'success');
 * updateStatus('Assembly failed: 2 error(s)', 'error');
 */
function updateStatus(message, type = 'info') {
  statusDisplay.textContent = `Status: ${message}`;
  statusDisplay.className = `status status-${type}`;
}

/**
 * Updates the character counter display
 * 
 * Shows remaining characters and applies visual styling based on
 * how close to the limit the user is.
 * 
 * @private
 */
function updateCharCounter() {
  const current = sourceEditor.value.length;
  const remaining = MAX_SOURCE_LENGTH - current;
  const percent = (current / MAX_SOURCE_LENGTH) * 100;
  
  // Update counter text
  charCounter.textContent = `(${current.toLocaleString()} / ${MAX_SOURCE_LENGTH.toLocaleString()} chars)`;
  
  // Update styling based on usage
  charCounter.className = 'char-counter';
  if (percent >= 95) {
    charCounter.classList.add('char-counter-danger');
  } else if (percent >= 80) {
    charCounter.classList.add('char-counter-warning');
  }
  
  // Prevent typing beyond limit
  if (current >= MAX_SOURCE_LENGTH) {
    sourceEditor.value = sourceEditor.value.substring(0, MAX_SOURCE_LENGTH);
  }
}

/**
 * Loads an example program into the source editor
 * 
 * Populates the editor with the example's source code and clears
 * all previous assembly outputs. Updates status to indicate which
 * example was loaded.
 * 
 * @private
 * @param {Object} example - Example program object
 * @param {string} example.name - Name of the example
 * @param {string} example.source - Z80 assembly source code
 * 
 * @example
 * // Typically called by the example dropdown
 * loadExample({
 *   name: 'Add 2+2',
 *   source: '.ORG $4200\nLD A, 2\n...'
 * });
 */
function loadExample(example) {
  sourceEditor.value = example.source;
  updateCharCounter(); // Update counter after loading
  updateStatus(`Loaded: ${example.name}`, 'info');
  
  // Clear previous assembly outputs
  outputDump.textContent = '';
  symbolTable.textContent = '';
  errorsDisplay.textContent = '';
  warningsDisplay.textContent = '';
}

/**
 * UI Initialization
 * Sets up event handlers and initial state
 */

// Initialize example program dropdown
initExamplesDropdown(exampleSelect, loadExample);

// Wire up assemble button click handler
assembleBtn.addEventListener('click', assemble);

/**
 * Keyboard shortcut: Ctrl+Enter to assemble
 * Allows quick assembly without clicking the button
 */
sourceEditor.addEventListener('keydown', (e) => {
  if (e.ctrlKey && e.key === 'Enter') {
    e.preventDefault();
    assemble();
  }
});

// Character counter: update on input
sourceEditor.addEventListener('input', updateCharCounter);

// Handle paste to truncate if needed
sourceEditor.addEventListener('paste', (e) => {
  const paste = (e.clipboardData || window.clipboardData).getData('text');
  const current = sourceEditor.value;
  const selectionStart = sourceEditor.selectionStart;
  const selectionEnd = sourceEditor.selectionEnd;
  
  // Calculate new length after paste
  const newLength = current.length - (selectionEnd - selectionStart) + paste.length;
  
  if (newLength > MAX_SOURCE_LENGTH) {
    e.preventDefault();
    // Truncate paste to fit
    const available = MAX_SOURCE_LENGTH - (current.length - (selectionEnd - selectionStart));
    const truncated = paste.substring(0, available);
    const newValue = current.substring(0, selectionStart) + truncated + current.substring(selectionEnd);
    sourceEditor.value = newValue;
    sourceEditor.setSelectionRange(selectionStart + truncated.length, selectionStart + truncated.length);
    updateCharCounter();
    updateStatus(`Paste truncated to fit ${MAX_SOURCE_LENGTH} character limit`, 'info');
  } else {
    // Let default paste happen, then update counter
    setTimeout(updateCharCounter, 0);
  }
});

// Set initial status message and character counter
updateStatus('Ready', 'info');
updateCharCounter();




================================================
FILE: src/opcodes.js
================================================
import { REG8, REG16, STACK_REG, CONDITIONS } from './constants.js';

/**
 * Instruction definitions
 * 
 * Each entry maps a pattern to encoding info:
 * - opcode: base opcode byte(s)
 * - prefix: optional prefix byte (0xCB, 0xDD, 0xED, 0xFD)
 * - operands: array describing expected operands
 * - size: total bytes including operands
 * - cycles: T-states (can be array for conditional instructions)
 */

// Simple single-byte instructions
export const SIMPLE_INSTRUCTIONS = {
  'NOP': { opcode: 0x00, size: 1, cycles: 4 },
  'HALT': { opcode: 0x76, size: 1, cycles: 4 },
  'DI': { opcode: 0xF3, size: 1, cycles: 4 },
  'EI': { opcode: 0xFB, size: 1, cycles: 4 },
  'EXX': { opcode: 0xD9, size: 1, cycles: 4 },
  'SCF': { opcode: 0x37, size: 1, cycles: 4 },
  'CCF': { opcode: 0x3F, size: 1, cycles: 4 },
  'CPL': { opcode: 0x2F, size: 1, cycles: 4 },
  'DAA': { opcode: 0x27, size: 1, cycles: 4 },
  'RLCA': { opcode: 0x07, size: 1, cycles: 4 },
  'RRCA': { opcode: 0x0F, size: 1, cycles: 4 },
  'RLA': { opcode: 0x17, size: 1, cycles: 4 },
  'RRA': { opcode: 0x1F, size: 1, cycles: 4 },
  'RET': { opcode: 0xC9, size: 1, cycles: 10 },
  'RETI': { prefix: 0xED, opcode: 0x4D, size: 2, cycles: 14 },
  'RETN': { prefix: 0xED, opcode: 0x45, size: 2, cycles: 14 },
  'NEG': { prefix: 0xED, opcode: 0x44, size: 2, cycles: 8 },
  'EX DE,HL': { opcode: 0xEB, size: 1, cycles: 4 },
  "EX AF,AF'": { opcode: 0x08, size: 1, cycles: 4 },
  'EX (SP),HL': { opcode: 0xE3, size: 1, cycles: 19 },
  'LDI': { prefix: 0xED, opcode: 0xA0, size: 2, cycles: 16 },
  'LDIR': { prefix: 0xED, opcode: 0xB0, size: 2, cycles: [21, 16] },
  'LDD': { prefix: 0xED, opcode: 0xA8, size: 2, cycles: 16 },
  'LDDR': { prefix: 0xED, opcode: 0xB8, size: 2, cycles: [21, 16] },
};

/**
 * LD instruction patterns - these are complex and need special handling
 */
export function encodeLD(operands) {
  const [dest, src] = operands;

  // LD r, r' - register to register
  if (REG8[dest] !== undefined && REG8[src] !== undefined) {
    return {
      bytes: [0x40 | (REG8[dest] << 3) | REG8[src]],
      size: 1
    };
  }

  // LD r, n - immediate to register
  if (REG8[dest] !== undefined && typeof src === 'number') {
    return {
      bytes: [0x06 | (REG8[dest] << 3), src & 0xFF],
      size: 2
    };
  }

  // LD r, (HL) - indirect to register
  if (REG8[dest] !== undefined && src === '(HL)') {
    return {
      bytes: [0x46 | (REG8[dest] << 3)],
      size: 1
    };
  }

  // LD (HL), r - register to indirect
  if (dest === '(HL)' && REG8[src] !== undefined) {
    return {
      bytes: [0x70 | REG8[src]],
      size: 1
    };
  }

  // LD (HL), n - immediate to indirect
  if (dest === '(HL)' && typeof src === 'number') {
    return {
      bytes: [0x36, src & 0xFF],
      size: 2
    };
  }

  // LD A, (BC)
  if (dest === 'A' && src === '(BC)') {
    return { bytes: [0x0A], size: 1 };
  }

  // LD A, (DE)
  if (dest === 'A' && src === '(DE)') {
    return { bytes: [0x1A], size: 1 };
  }

  // LD A, (nn) - extended addressing
  // Handle both number addresses and label reference objects
  if (dest === 'A') {
    if (typeof src === 'number' && src > 255) {
      return {
        bytes: [0x3A, src & 0xFF, (src >> 8) & 0xFF],
        size: 3
      };
    }
    if (src && typeof src === 'object' && src.type === 'LABEL_REF') {
      // This will be resolved in codegen, but for now check if it's an address
      const addr = src.address;
      if (addr > 255) {
        return {
          bytes: [0x3A, addr & 0xFF, (addr >> 8) & 0xFF],
          size: 3
        };
      }
    }
    // LD A, n - 8-bit immediate
    if (typeof src === 'number' && src <= 255) {
      return {
        bytes: [0x3E, src & 0xFF],
        size: 2
      };
    }
  }

  // LD (BC), A
  if (dest === '(BC)' && src === 'A') {
    return { bytes: [0x02], size: 1 };
  }

  // LD (DE), A
  if (dest === '(DE)' && src === 'A') {
    return { bytes: [0x12], size: 1 };
  }

  // LD (nn), A
  // dest should be a number (address) - label references are resolved in codegen
  if (typeof dest === 'number' && src === 'A') {
    // Indirect addressing (nn) passed as number
    return {
      bytes: [0x32, dest & 0xFF, (dest >> 8) & 0xFF],
      size: 3
    };
  }

  // LD dd, nn - 16-bit immediate load
  // This matches any 16-bit register with a number
  if (REG16[dest] !== undefined && typeof src === 'number') {
    return {
      bytes: [0x01 | (REG16[dest] << 4), src & 0xFF, (src >> 8) & 0xFF],
      size: 3
    };
  }

  // LD SP, HL
  if (dest === 'SP' && src === 'HL') {
    return { bytes: [0xF9], size: 1 };
  }

  // LD (nn), HL
  if ((typeof dest === 'number' || (dest && typeof dest === 'object' && dest.type === 'LABEL_REF')) && src === 'HL') {
    const addr = typeof dest === 'number' ? dest : (dest.address || 0);
    return {
      bytes: [0x22, addr & 0xFF, (addr >> 8) & 0xFF],
      size: 3
    };
  }

  // LD HL, (nn)
  if (dest === 'HL' && (typeof src === 'number' || (src && typeof src === 'object' && src.type === 'LABEL_REF'))) {
    const addr = typeof src === 'number' ? src : (src.address || 0);
    return {
      bytes: [0x2A, addr & 0xFF, (addr >> 8) & 0xFF],
      size: 3
    };
  }

  throw new Error(`Unsupported LD pattern: ${dest}, ${src}`);
}

/**
 * JP instruction patterns
 */
export function encodeJP(operands) {
  if (operands.length === 1) {
    const target = operands[0];

    // JP (HL)
    if (target === '(HL)') {
      return { bytes: [0xE9], size: 1, cycles: 4 };
    }

    // JP nn - unconditional jump
    if (typeof target === 'number') {
      return {
        bytes: [0xC3, target & 0xFF, (target >> 8) & 0xFF],
        size: 3,
        cycles: 10
      };
    }
  }

  // JP cc, nn - conditional jump
  if (operands.length === 2) {
    const [cc, target] = operands;
    if (CONDITIONS[cc] !== undefined && typeof target === 'number') {
      return {
        bytes: [0xC2 | (CONDITIONS[cc] << 3), target & 0xFF, (target >> 8) & 0xFF],
        size: 3,
        cycles: 10
      };
    }
  }

  throw new Error(`Unsupported JP pattern: ${operands.join(', ')}`);
}

/**
 * JR instruction patterns (relative jumps)
 */
export function encodeJR(operands) {
  if (operands.length === 1) {
    const offset = operands[0];
    if (typeof offset === 'number') {
      // Offset is already calculated relative to instruction end
      // Convert to signed 8-bit
      const relOffset = offset < 0 ? (0x100 + offset) : offset;
      return {
        bytes: [0x18, relOffset & 0xFF],
        size: 2,
        cycles: 12
      };
    }
  }

  // JR cc, e - conditional relative
  if (operands.length === 2) {
    const [cc, offset] = operands;
    if (typeof offset === 'number') {
      const relOffset = offset < 0 ? (0x100 + offset) : offset;
      const opcodes = {
        'NZ': 0x20, 'Z': 0x28, 'NC': 0x30, 'C': 0x38
      };
      if (opcodes[cc] !== undefined) {
        return {
          bytes: [opcodes[cc], relOffset & 0xFF],
          size: 2,
          cycles: [12, 7]
        };
      }
    }
  }

  throw new Error(`Unsupported JR pattern: ${operands.join(', ')}`);
}

/**
 * DJNZ instruction
 */
export function encodeDJNZ(offset) {
  if (typeof offset === 'number') {
    // Offset is already calculated relative to instruction end
    const relOffset = offset < 0 ? (0x100 + offset) : offset;
    return {
      bytes: [0x10, relOffset & 0xFF],
      size: 2,
      cycles: [13, 8]
    };
  }
  throw new Error(`Invalid DJNZ offset: ${offset}`);
}

/**
 * Arithmetic/Logic operations
 */
export const ALU_OPCODES = {
  'ADD': 0x80, 'ADC': 0x88, 'SUB': 0x90, 'SBC': 0x98,
  'AND': 0xA0, 'XOR': 0xA8, 'OR':  0xB0, 'CP':  0xB8
};

export const ALU_IMM_OPCODES = {
  'ADD': 0xC6, 'ADC': 0xCE, 'SUB': 0xD6, 'SBC': 0xDE,
  'AND': 0xE6, 'XOR': 0xEE, 'OR':  0xF6, 'CP':  0xFE
};

export function encodeALU(mnemonic, operands) {
  if (operands.length === 1) {
    const op = operands[0];

    // ALU A, r
    if (REG8[op] !== undefined) {
      return {
        bytes: [ALU_OPCODES[mnemonic] | REG8[op]],
        size: 1
      };
    }

    // ALU A, (HL)
    if (op === '(HL)') {
      return {
        bytes: [ALU_OPCODES[mnemonic] | 6],
        size: 1
      };
    }

    // ALU A, n - immediate
    if (typeof op === 'number') {
      return {
        bytes: [ALU_IMM_OPCODES[mnemonic], op & 0xFF],
        size: 2
      };
    }
  }

  // ALU A, r (explicit A operand)
  if (operands.length === 2 && operands[0] === 'A') {
    return encodeALU(mnemonic, [operands[1]]);
  }

  throw new Error(`Unsupported ${mnemonic} pattern: ${operands.join(', ')}`);
}

/**
 * ADD HL,ss - 16-bit addition
 */
export function encodeADDHL(operands) {
  if (operands.length === 2 && operands[0] === 'HL' && REG16[operands[1]] !== undefined) {
    return {
      bytes: [0x09 | (REG16[operands[1]] << 4)],
      size: 1
    };
  }
  throw new Error(`Unsupported ADD HL pattern: ${operands.join(', ')}`);
}

/**
 * INC/DEC patterns
 */
export function encodeINC(operand) {
  // 8-bit INC r
  if (REG8[operand] !== undefined) {
    return {
      bytes: [0x04 | (REG8[operand] << 3)],
      size: 1
    };
  }

  // INC (HL)
  if (operand === '(HL)') {
    return { bytes: [0x34], size: 1 };
  }

  // 16-bit INC rr
  if (REG16[operand] !== undefined) {
    return {
      bytes: [0x03 | (REG16[operand] << 4)],
      size: 1
    };
  }

  throw new Error(`Unsupported INC operand: ${operand}`);
}

export function encodeDEC(operand) {
  // 8-bit DEC r
  if (REG8[operand] !== undefined) {
    return {
      bytes: [0x05 | (REG8[operand] << 3)],
      size: 1
    };
  }

  // DEC (HL)
  if (operand === '(HL)') {
    return { bytes: [0x35], size: 1 };
  }

  // 16-bit DEC rr
  if (REG16[operand] !== undefined) {
    return {
      bytes: [0x0B | (REG16[operand] << 4)],
      size: 1
    };
  }

  throw new Error(`Unsupported DEC operand: ${operand}`);
}

/**
 * PUSH/POP patterns
 */
export function encodePUSH(operand) {
  if (STACK_REG[operand] !== undefined) {
    return {
      bytes: [0xC5 | (STACK_REG[operand] << 4)],
      size: 1
    };
  }
  throw new Error(`Unsupported PUSH operand: ${operand}`);
}

export function encodePOP(operand) {
  if (STACK_REG[operand] !== undefined) {
    return {
      bytes: [0xC1 | (STACK_REG[operand] << 4)],
      size: 1
    };
  }
  throw new Error(`Unsupported POP operand: ${operand}`);
}

/**
 * CALL patterns
 */
export function encodeCALL(operands) {
  if (operands.length === 1) {
    const target = operands[0];
    if (typeof target === 'number') {
      return {
        bytes: [0xCD, target & 0xFF, (target >> 8) & 0xFF],
        size: 3
      };
    }
  }

  // CALL cc, nn
  if (operands.length === 2) {
    const [cc, target] = operands;
    if (CONDITIONS[cc] !== undefined && typeof target === 'number') {
      return {
        bytes: [0xC4 | (CONDITIONS[cc] << 3), target & 0xFF, (target >> 8) & 0xFF],
        size: 3
      };
    }
  }

  throw new Error(`Unsupported CALL pattern: ${operands.join(', ')}`);
}

/**
 * RET cc patterns
 */
export function encodeRETCC(cc) {
  if (CONDITIONS[cc] !== undefined) {
    return {
      bytes: [0xC0 | (CONDITIONS[cc] << 3)],
      size: 1
    };
  }
  throw new Error(`Unsupported RET condition: ${cc}`);
}

/**
 * RST patterns (restart)
 */
export function encodeRST(addr) {
  if (typeof addr === 'number' && (addr & 0x38) === addr && addr >= 0 && addr <= 0x38) {
    return {
      bytes: [0xC7 | (addr & 0x38)],
      size: 1
    };
  }
  throw new Error(`Invalid RST address: ${addr}`);
}

/**
 * CB-prefixed instructions (rotate/shift/bit)
 */
export const CB_INSTRUCTIONS = {
  'RLC':  0x00, 'RRC':  0x08, 'RL':   0x10, 'RR':   0x18,
  'SLA':  0x20, 'SRA':  0x28, 'SLL':  0x30, 'SRL':  0x38,
  'BIT':  0x40, 'RES':  0x80, 'SET':  0xC0
};

export function encodeCB(mnemonic, operands) {
  if (mnemonic === 'BIT' || mnemonic === 'SET' || mnemonic === 'RES') {
    // BIT/SET/RES b, r or BIT/SET/RES b, (HL)
    if (operands.length === 2) {
      const [bit, reg] = operands;
      if (typeof bit === 'number' && bit >= 0 && bit <= 7) {
        if (reg === '(HL)') {
          return {
            bytes: [0xCB, CB_INSTRUCTIONS[mnemonic] | (bit << 3) | 6],
            size: 2
          };
        }
        if (REG8[reg] !== undefined) {
          return {
            bytes: [0xCB, CB_INSTRUCTIONS[mnemonic] | (bit << 3) | REG8[reg]],
            size: 2
          };
        }
      }
    }
  } else {
    // RLC/RRC/RL/RR/SLA/SRA/SLL/SRL r or (HL)
    if (operands.length === 1) {
      const reg = operands[0];
      if (reg === '(HL)') {
        return {
          bytes: [0xCB, CB_INSTRUCTIONS[mnemonic] | 6],
          size: 2
        };
      }
      if (REG8[reg] !== undefined) {
        return {
          bytes: [0xCB, CB_INSTRUCTIONS[mnemonic] | REG8[reg]],
          size: 2
        };
      }
    }
  }

  throw new Error(`Unsupported CB instruction: ${mnemonic} ${operands.join(', ')}`);
}

/**
 * IN/OUT instructions
 */
export function encodeIN(operands) {
  // IN A, (n)
  if (operands.length === 2 && operands[0] === 'A') {
    const port = operands[1];
    if (typeof port === 'number') {
      return {
        bytes: [0xDB, port & 0xFF],
        size: 2
      };
    }
  }
  throw new Error(`Unsupported IN pattern: ${operands.join(', ')}`);
}

export function encodeOUT(operands) {
  // OUT (n), A
  if (operands.length === 2 && operands[1] === 'A') {
    const port = operands[0];
    if (typeof port === 'number') {
      return {
        bytes: [0xD3, port & 0xFF],
        size: 2
      };
    }
  }
  throw new Error(`Unsupported OUT pattern: ${operands.join(', ')}`);
}




================================================
FILE: src/parser.js
================================================
import { TOKEN, MEMORY, CONDITIONS, REG8, REG16 } from './constants.js';
import { ExpressionEvaluator } from './evaluator.js';

export class Parser {
  constructor(tokens) {
    this.tokens = tokens.filter(t => t.type !== TOKEN.COMMENT); // strip comments
    this.pos = 0;
    this.errors = [];
    this.warnings = [];
    this.symbolTable = {};
    this.currentAddress = MEMORY.DEFAULT_ORG;
    this.instructions = []; // intermediate representation
    this.pass = 1; // Track which pass we're in
  }

  /**
   * Two-pass assembly
   * Pass 1: Collect labels and calculate addresses
   * Pass 2: Resolve forward references and generate code
   */
  parse() {
    // Pass 1
    this.pass = 1;
    this.pos = 0;
    this.currentAddress = MEMORY.DEFAULT_ORG;
    this.symbolTable = {};
    
    while (!this.isAtEnd()) {
      try {
        this.parseLinePass1();
      } catch (e) {
        this.errors.push({ message: e.message, line: this.currentLine() });
        this.synchronize();
      }
    }

    // Pass 2
    this.pass = 2;
    this.pos = 0;
    this.currentAddress = MEMORY.DEFAULT_ORG;
    this.instructions = [];
    
    while (!this.isAtEnd()) {
      try {
        this.parseLinePass2();
      } catch (e) {
        this.errors.push({ message: e.message, line: this.currentLine() });
        this.synchronize();
      }
    }

    return {
      instructions: this.instructions,
      symbolTable: this.symbolTable,
      errors: this.errors,
      warnings: this.warnings,
      startAddress: MEMORY.DEFAULT_ORG
    };
  }

  parseLinePass1() {
    // Skip newlines
    while (this.check(TOKEN.NEWLINE)) {
      this.advance();
    }
    if (this.isAtEnd()) return;

    // Check for label (with colon) - defines label at current address
    if (this.check(TOKEN.LABEL) && this.checkNext(TOKEN.COLON)) {
      const label = this.advance();
      this.advance(); // consume colon
      this.defineSymbol(label.value, this.currentAddress);
    }
    
    // Check for label before directive (without colon) - e.g., LABEL .EQU value
    // Consume the label so we can process the directive
    if (this.check(TOKEN.LABEL) && !this.checkNext(TOKEN.COLON)) {
      const nextToken = this.tokens[this.pos + 1];
      if (nextToken && nextToken.type === TOKEN.DIRECTIVE) {
        const directiveValue = nextToken.value.toUpperCase();
        // For EQU and DEFL, don't define the label here - let the directive handler do it
        // For other directives like .DB, define the label at current address
        if (directiveValue !== '.EQU' && directiveValue !== 'EQU' && 
            directiveValue !== '.DEFL' && directiveValue !== 'DEFL') {
          const label = this.advance(); // consume label
          this.defineSymbol(label.value, this.currentAddress);
        } else {
          // For EQU/DEFL, just consume the label without defining it
          this.advance();
        }
      }
    }

    // Check for directive
    if (this.check(TOKEN.DIRECTIVE)) {
      // Label should already be consumed above, so just process the directive
      this.parseDirectivePass1();
      return;
    }

    // Check for instruction
    if (this.check(TOKEN.MNEMONIC)) {
      const size = this.calculateInstructionSize();
      this.currentAddress += size;
      // Skip the instruction and its operands
      this.skipToNewline();
      return;
    }

    // Unknown - skip to newline
    this.skipToNewline();
  }

  parseLinePass2() {
    // Skip newlines
    while (this.check(TOKEN.NEWLINE)) {
      this.advance();
    }
    if (this.isAtEnd()) return;

    // Check for label (with colon)
    if (this.check(TOKEN.LABEL) && this.checkNext(TOKEN.COLON)) {
      const afterColon = this.tokens[this.pos + 2];
      if (afterColon && afterColon.type === TOKEN.DIRECTIVE) {
        // Label before directive - advance past label and colon
        // so directive can be processed, and parseDBPass2 can detect the label
        this.advance(); // consume label
        this.advance(); // consume colon
        // Now at directive - it will be processed below
      } else {
        const label = this.advance();
        this.advance(); // colon
        // Symbol table will be updated in codegen with actual addresses
      }
    }
    
    // Check for label before directive without colon (like RESULT .DB 0)
    if (this.check(TOKEN.LABEL) && !this.checkNext(TOKEN.COLON)) {
      const nextToken = this.tokens[this.pos + 1];
      if (nextToken && nextToken.type === TOKEN.DIRECTIVE) {
        // Label before directive - advance past label
        this.advance(); // consume label
        // Now at directive - it will be processed below
      }
    }
    
    // Check for directive
    if (this.check(TOKEN.DIRECTIVE)) {
      this.parseDirectivePass2();
      return;
    }

    // Check for instruction
    if (this.check(TOKEN.MNEMONIC)) {
      this.parseInstruction();
      return;
    }

    // Unknown - skip to newline
    this.skipToNewline();
  }

  parseDirectivePass1() {
    const directive = this.advance();

    switch (directive.value) {
      case '.ORG':
      case 'ORG':
        const addr = this.parseExpressionValue();
        this.currentAddress = addr;
        break;

      case '.EQU':
      case 'EQU':
        // EQU format: LABEL .EQU value
        // The label is BEFORE the directive, so look back for it
        let equLabel = null;
        if (this.pos > 1) {
          const prevToken = this.tokens[this.pos - 2]; // -2 because we already advanced past directive
          if (prevToken && prevToken.type === TOKEN.LABEL) {
            equLabel = prevToken.value;
          }
        }
        if (equLabel) {
          // For .EQU, don't allow forward references - evaluate immediately
          const value = this.parseExpressionValue(false);
          this.defineSymbol(equLabel, value, 'EQU');
        }
        break;

      case '.DEFL':
      case 'DEFL':
        // DEFL format: LABEL .DEFL value (similar to EQU)
        let deflLabel = null;
        if (this.pos > 1) {
          const prevToken = this.tokens[this.pos - 2]; // -2 because we already advanced past directive
          if (prevToken && prevToken.type === TOKEN.LABEL) {
            deflLabel = prevToken.value;
          }
        }
        if (deflLabel) {
          const value = this.parseExpressionValue(false);
          this.defineSymbol(deflLabel, value, 'DEFL');
        }
        break;

      case '.DB':
      case 'DB':
      case 'DEFB':
        this.parseDBPass1();
        break;

      case '.DW':
      case 'DW':
      case 'DEFW':
        this.parseDWPass1();
        break;

      case '.DS':
      case 'DS':
      case 'DEFS':
        const count = this.parseExpressionValue();
        this.currentAddress += count;
        break;

      case '.END':
      case 'END':
        // End of source - stop parsing
        while (!this.isAtEnd()) {
          this.advance();
        }
        break;
    }

    this.skipToNewline();
  }

  parseDirectivePass2() {
    const directive = this.advance();

    switch (directive.value) {
      case '.ORG':
      case 'ORG':
        const addr = this.parseExpressionValue();
        this.currentAddress = addr;
        break;

      case '.EQU':
      case 'EQU':
      case '.DEFL':
      case 'DEFL':
        // Skip - already defined in pass 1
        if (this.check(TOKEN.LABEL)) {
          this.advance();
        }
        if (this.check(TOKEN.COMMA)) {
          this.advance(); // consume comma if present
        }
        this.parseExpressionValue();
        break;

      case '.DB':
      case 'DB':
      case 'DEFB':
        // Check if there's a label before this directive
        if (this.pos > 0) {
          const prevToken = this.tokens[this.pos - 1];
          if (prevToken && prevToken.type === TOKEN.LABEL && !this.check(TOKEN.COLON)) {
            // Label was already processed, but make sure it's defined
            // (handled in parseLinePass2 label check)
          }
        }
        this.parseDBPass2();
        break;

      case '.DW':
      case 'DW':
      case 'DEFW':
        // Check if there's a label before this directive
        if (this.pos > 0) {
          const prevToken = this.tokens[this.pos - 1];
          if (prevToken && prevToken.type === TOKEN.LABEL && !this.check(TOKEN.COLON)) {
            // Label was already processed
          }
        }
        this.parseDWPass2();
        break;

      case '.DS':
      case 'DS':
      case 'DEFS':
        const count = this.parseExpressionValue();
        // Reserve space (fill with zeros)
        for (let i = 0; i < count; i++) {
          this.instructions.push({
            type: 'DATA',
            bytes: [0],
            address: this.currentAddress++
          });
        }
        break;

      case '.END':
      case 'END':
        while (!this.isAtEnd()) {
          this.advance();
        }
        break;
    }

    this.skipToNewline();
  }

  parseDBPass1() {
    // Count bytes
    let count = 0;
    const startPos = this.pos;
    
    while (!this.check(TOKEN.NEWLINE) && !this.isAtEnd()) {
      if (this.check(TOKEN.STRING)) {
        const str = this.advance();
        count += str.value.length;
      } else if (this.check(TOKEN.NUMBER)) {
        this.advance();
        count++;
      } else if (this.check(TOKEN.COMMA)) {
        this.advance();
      } else {
        break;
      }
    }
    
    this.currentAddress += count;
    this.pos = startPos; // Reset for pass 2
  }

  parseDBPass2() {
    // Check if there's a label before this directive
    // After parseDirectivePass2 consumes .DB, we're at:
    // pos-3: LABEL, pos-2: COLON, pos-1: .DB (already consumed), pos: first data token
    let labelName = null;
    
    // Look back for label pattern: LABEL COLON .DB or LABEL .DB
    if (this.pos > 2) {
      const tok1 = this.tokens[this.pos - 1]; // Should be .DB
      const tok2 = this.tokens[this.pos - 2]; // Could be COLON
      const tok3 = this.tokens[this.pos - 3]; // Could be LABEL
      
      if (tok3 && tok3.type === TOKEN.LABEL && tok2 && tok2.type === TOKEN.COLON && tok1 && tok1.type === TOKEN.DIRECTIVE) {
        // Pattern: LABEL COLON .DB
        labelName = tok3.value;
      }
    }
    
    if (!labelName && this.pos > 1) {
      const tok1 = this.tokens[this.pos - 1]; // Should be .DB
      const tok2 = this.tokens[this.pos - 2]; // Could be LABEL
      
      if (tok2 && tok2.type === TOKEN.LABEL && tok1 && tok1.type === TOKEN.DIRECTIVE) {
        // Pattern: LABEL .DB
        labelName = tok2.value;
      }
    }
    
    // Also check current position in case label wasn't consumed yet
    if (!labelName && this.check(TOKEN.LABEL)) {
      const label = this.peek();
      const nextToken = this.tokens[this.pos + 1];
      if (nextToken && (nextToken.type === TOKEN.COLON || nextToken.type === TOKEN.NUMBER || nextToken.type === TOKEN.STRING)) {
        labelName = label.value;
        if (nextToken.type === TOKEN.COLON) {
          this.advance(); // consume label
          this.advance(); // consume colon
        } else {
          this.advance(); // consume label only
        }
      }
    }
    
    // Generate the data at current address
    let firstData = true;
    while (!this.check(TOKEN.NEWLINE) && !this.isAtEnd()) {
      if (this.check(TOKEN.STRING)) {
        const str = this.advance();
        for (let i = 0; i < str.value.length; i++) {
          this.instructions.push({
            type: 'DATA',
            bytes: [str.value.charCodeAt(i) & 0xFF],
            address: this.currentAddress,
            label: (firstData && i === 0) ? labelName : null
          });
          this.currentAddress++;
          firstData = false;
        }
      } else if (this.check(TOKEN.NUMBER) || this.check(TOKEN.LABEL)) {
        const num = this.parseExpressionValue();
        this.instructions.push({
          type: 'DATA',
          bytes: [num & 0xFF],
          address: this.currentAddress,
          label: firstData ? labelName : null
        });
        this.currentAddress++;
        firstData = false;
      } else if (this.check(TOKEN.COMMA)) {
        this.advance();
      } else {
        break;
      }
    }
  }

  parseDWPass1() {
    // Count words (2 bytes each)
    let count = 0;
    const startPos = this.pos;
    
    while (!this.check(TOKEN.NEWLINE) && !this.isAtEnd()) {
      if (this.check(TOKEN.NUMBER) || this.check(TOKEN.LABEL)) {
        this.advance();
        count++;
      } else if (this.check(TOKEN.COMMA)) {
        this.advance();
      } else {
        break;
      }
    }
    
    this.currentAddress += count * 2;
    this.pos = startPos; // Reset for pass 2
  }

  parseDWPass2() {
    while (!this.check(TOKEN.NEWLINE) && !this.isAtEnd()) {
      if (this.check(TOKEN.NUMBER) || this.check(TOKEN.LABEL)) {
        const value = this.parseExpressionValue();
        const lo = value & 0xFF;
        const hi = (value >> 8) & 0xFF;
        this.instructions.push({
          type: 'DATA',
          bytes: [lo, hi],
          address: this.currentAddress
        });
        this.currentAddress += 2;
      } else if (this.check(TOKEN.COMMA)) {
        this.advance();
      } else {
        break;
      }
    }
  }

  parseInstruction() {
    const mnemonic = this.advance();
    const operands = this.parseOperands();
    
    // Check if there was a label before this instruction (with colon)
    let labelName = null;
    if (this.pos > 1) {
      const prevToken = this.tokens[this.pos - 2];
      const prevPrev = this.tokens[this.pos - 3];
      if (prevToken && prevToken.type === TOKEN.COLON && prevPrev && prevPrev.type === TOKEN.LABEL) {
        labelName = prevPrev.value;
      }
    }

    this.instructions.push({
      type: 'INSTRUCTION',
      mnemonic: mnemonic.value,
      operands: operands,
      address: this.currentAddress,
      bytes: [], // Will be filled by code generator
      label: labelName // Store label name if present
    });

    // Estimate size for address tracking in pass 2
    // For size estimation, we can resolve operands (using pass 1 addresses is OK for estimation)
    const size = this.estimateInstructionSize(mnemonic.value, operands);
    this.currentAddress += size;
  }
  
  estimateInstructionSize(mnemonic, operands) {
    // Quick size estimation based on mnemonic and operands
    if (['NOP', 'HALT', 'DI', 'EI', 'SCF', 'CCF', 'CPL', 'DAA', 'RLCA', 'RRCA', 'RLA', 'RRA', 'RET', 'EXX'].includes(mnemonic)) {
      return 1;
    }
    if (['LDIR', 'LDDR', 'LDI', 'LDD', 'RETI', 'RETN', 'NEG'].includes(mnemonic)) {
      return 2;
    }
    if (['JP', 'CALL'].includes(mnemonic)) {
      return 3;
    }
    if (['JR', 'DJNZ'].includes(mnemonic)) {
      return 2;
    }
    if (mnemonic === 'LD' && operands.length === 2) {
      // Check operand types
      const [op1, op2] = operands;
      if (typeof op1 === 'number' && op1 > 255) return 3;
      if (typeof op2 === 'number' && op2 > 255) return 3;
      if (typeof op2 === 'number' && op2 <= 255 && typeof op1 === 'string' && REG8[op1] !== undefined) return 2;
      if (op1 === '(HL)' || op2 === '(HL)') return 1;
      if (typeof op1 === 'string' && REG8[op1] && typeof op2 === 'string' && REG8[op2]) return 1;
      return 2; // Default estimate
    }
    if (['ADD', 'ADC', 'SUB', 'SBC', 'AND', 'OR', 'XOR', 'CP'].includes(mnemonic)) {
      if (operands.length === 1 && typeof operands[0] === 'number') return 2;
      return 1;
    }
    if (mnemonic === 'ADD' && operands.length === 2 && operands[0] === 'HL') {
      return 1;
    }
    if (['INC', 'DEC', 'PUSH', 'POP'].includes(mnemonic)) {
      return 1;
    }
    if (['BIT', 'SET', 'RES', 'RLC', 'RRC', 'RL', 'RR', 'SLA', 'SRA', 'SLL', 'SRL'].includes(mnemonic)) {
      return 2;
    }
    if (['IN', 'OUT'].includes(mnemonic)) {
      return 2;
    }
    return 1; // Default
  }

  parseOperands() {
    const operands = [];

    if (this.check(TOKEN.NEWLINE) || this.isAtEnd()) {
      return operands;
    }

    // Parse first operand
    operands.push(this.parseOperand());

    // Parse additional operands separated by commas
    while (this.check(TOKEN.COMMA)) {
      this.advance(); // consume comma
      operands.push(this.parseOperand());
    }

    return operands;
  }

  parseOperand() {
    // Handle (HL), (BC), (DE), (nn) patterns first
    if (this.check(TOKEN.LPAREN)) {
      this.advance(); // consume (
      
      // Check for register in parentheses
      if (this.check(TOKEN.REGISTER)) {
        const reg = this.advance();
        this.consume(TOKEN.RPAREN);
        
        if (reg.value === 'HL') return '(HL)';
        if (reg.value === 'BC') return '(BC)';
        if (reg.value === 'DE') return '(DE)';
        throw new Error(`Invalid register in parentheses: ${reg.value}`);
      }
      
      // In pass 2, check if it's just a label in parentheses FIRST (before expression parsing)
      if (this.pass === 2) {
        const savedPos = this.pos;
        // Skip whitespace/newlines to find next meaningful token
        let checkPos = this.pos;
        while (checkPos < this.tokens.length) {
          const tok = this.tokens[checkPos];
          if (tok.type === TOKEN.NEWLINE || tok.type === TOKEN.COMMENT) {
            checkPos++;
            continue;
          }
          // Found a meaningful token
          if (tok.type === TOKEN.LABEL) {
            // Check if next meaningful token after label is RPAREN (not operator)
            let nextCheck = checkPos + 1;
            while (nextCheck < this.tokens.length) {
              const nextTok = this.tokens[nextCheck];
              if (nextTok.type === TOKEN.NEWLINE || nextTok.type === TOKEN.COMMENT) {
                nextCheck++;
                continue;
              }
              if (nextTok.type === TOKEN.RPAREN) {
                // It's (label) - store as label reference for deferred resolution
                const label = this.tokens[checkPos];
                this.pos = nextCheck + 1; // Advance past RPAREN
                return { type: 'LABEL_REF', name: label.value };
              }
              // Next token is not RPAREN - it's an expression
              break;
            }
          }
          // Not a label or it's part of an expression
          break;
        }
        this.pos = savedPos;
      }
      
      // For expressions or pass 1, parse normally
      // Check if it's an expression starting with $, number, or label
      const nextType = this.peek()?.type;
      if (nextType === TOKEN.OPERATOR || nextType === TOKEN.NUMBER || nextType === TOKEN.LABEL) {
        // It's an expression, parse it
        const addr = this.parseExpressionValue();
        this.consume(TOKEN.RPAREN);
        return addr; // Return as number for (nn) addressing
      }
      
      // Fallback: parse as expression
      const addr = this.parseExpressionValue();
      this.consume(TOKEN.RPAREN);
      return addr; // Return as number for (nn) addressing
    }

    // Check if this is an expression (starts with $, number, or label followed by operator)
    const nextType = this.tokens[this.pos + 1]?.type;
    if (this.check(TOKEN.OPERATOR) && this.peek().value === '$') {
      // Expression starting with $ (current address)
      return this.parseExpressionValue();
    }
    
    if (this.check(TOKEN.NUMBER)) {
      // Check if followed by operator - if so, it's an expression
      if (nextType === TOKEN.OPERATOR) {
        return this.parseExpressionValue();
      }
      return this.parseExpressionValue();
    }

    if (this.check(TOKEN.REGISTER)) {
      const reg = this.advance();
      return reg.value;
    }

    if (this.check(TOKEN.LABEL)) {
      const labelToken = this.peek();
      
      // Check if it's a condition code (used in JP cc, JR cc, CALL cc, RET cc)
      if (CONDITIONS[labelToken.value] !== undefined) {
        const cond = this.advance();
        return cond.value; // Return condition code as string
      }
      
      // Check if this is part of an expression (next token is operator)
      if (nextType === TOKEN.OPERATOR || nextType === TOKEN.LPAREN) {
        // It's an expression, parse it
        return this.parseExpressionValue();
      }
      
      // Single label reference
      const label = this.advance();
      
      // In pass 2, don't resolve labels during parsing - store label name
      // Resolution will happen in codegen when all labels are updated
      if (this.pass === 2) {
        // Store as special marker object to indicate it needs resolution
        return { type: 'LABEL_REF', name: label.value };
      }
      
      // Pass 1: resolve or return placeholder
      const symbol = this.symbolTable[label.value];
      if (symbol === undefined) {
        // Forward reference in pass 1 - return placeholder
        return 0;
      }
      return symbol.address;
    }

    throw new Error(`Unexpected operand token: ${this.peek()?.type}`);
  }

  parseExpressionValue(allowForwardRefs = true) {
    const evaluator = new ExpressionEvaluator(this.symbolTable, this.currentAddress);
    const exprTokens = this.collectExpressionTokens();
    try {
      return evaluator.evaluate(exprTokens);
    } catch (e) {
      // In pass 1, forward references are OK for size calculation
      // But for .EQU, we need actual values, so don't allow forward refs there
      if (allowForwardRefs && (e.message.includes('Undefined symbol') || e.message.includes('Undefined label'))) {
        return 0; // Placeholder for pass 1
      }
      throw e;
    }
  }

  collectExpressionTokens() {
    const tokens = [];
    let depth = 0;

    while (!this.isAtEnd()) {
      const token = this.peek();

      if (token.type === TOKEN.NEWLINE) break;
      if (token.type === TOKEN.COMMA && depth === 0) break;

      if (token.type === TOKEN.LPAREN) depth++;
      if (token.type === TOKEN.RPAREN) {
        if (depth === 0) break;
        depth--;
      }

      tokens.push(this.advance());
    }

    return tokens;
  }

  calculateInstructionSize() {
    const startPos = this.pos;
    const mnemonic = this.peek();
    
    if (!mnemonic || mnemonic.type !== TOKEN.MNEMONIC) {
      this.pos = startPos;
      return 0;
    }

    const mnem = mnemonic.value;
    this.advance(); // consume mnemonic
    
    // Instructions with no operands
    if (['NOP', 'HALT', 'DI', 'EI', 'SCF', 'CCF', 'CPL', 'DAA', 'RLCA', 'RRCA', 'RLA', 'RRA', 'RET', 'EXX', 'EX DE,HL', 'EX AF,AF\''].includes(mnem)) {
      this.pos = startPos;
      return 1;
    }
    
    // ED-prefixed instructions (2 bytes)
    if (['LDIR', 'LDDR', 'LDI', 'LDD', 'RETI', 'RETN', 'NEG'].includes(mnem)) {
      this.pos = startPos;
      return 2;
    }
    
    // Always 3-byte instructions
    if (['JP', 'CALL'].includes(mnem)) {
      // Check if conditional (2 operands = conditional, 1 = unconditional, both 3 bytes)
      this.skipToNewline();
      this.pos = startPos;
      return 3;
    }
    
    // Always 2-byte relative jumps
    if (['JR', 'DJNZ'].includes(mnem)) {
      this.skipToNewline();
      this.pos = startPos;
      return 2;
    }
    
    // Try to parse operands to determine size
    let operandCount = 0;
    let hasImmediate = false;
    let has16Bit = false;
    let hasRegister = false;
    let hasIndirect = false;
    
    while (!this.check(TOKEN.NEWLINE) && !this.isAtEnd()) {
      if (this.check(TOKEN.NUMBER) || this.check(TOKEN.OPERATOR)) {
        // Could be immediate value or expression
        const savedPos = this.pos;
        try {
          const val = this.parseExpressionValue(true); // Allow forward refs for size calc
          hasImmediate = true;
          if (val > 255 || val < 0) has16Bit = true;
          operandCount++;
        } catch (e) {
          this.pos = savedPos;
          // Estimate: if it's a number token, likely immediate
          if (this.check(TOKEN.NUMBER)) {
            this.advance();
            hasImmediate = true;
            operandCount++;
          } else {
            break;
          }
        }
      } else if (this.check(TOKEN.LABEL)) {
        // Could be label (forward ref) or condition code
        const label = this.peek();
        if (CONDITIONS[label.value] !== undefined) {
          this.advance(); // condition code
          operandCount++;
        } else {
          // Forward reference - estimate based on instruction
          this.advance();
          operandCount++;
          // For size calculation, assume it's an address if in certain contexts
          if (mnem === 'LD' || mnem === 'JP' || mnem === 'CALL') {
            has16Bit = true;
          }
        }
      } else if (this.check(TOKEN.REGISTER)) {
        this.advance();
        hasRegister = true;
        operandCount++;
      } else if (this.check(TOKEN.COMMA)) {
        this.advance();
      } else if (this.check(TOKEN.LPAREN)) {
        this.advance();
        if (this.check(TOKEN.REGISTER)) {
          this.advance();
          this.consume(TOKEN.RPAREN);
          hasIndirect = true;
          operandCount++;
        } else {
          // (nn) - 16-bit address
          has16Bit = true;
          hasIndirect = true;
          // Try to parse, but don't fail on forward refs
          const savedPos = this.pos;
          try {
            this.parseExpressionValue(true);
          } catch (e) {
            // Ignore - it's a forward ref, assume 16-bit
          }
          this.consume(TOKEN.RPAREN);
          operandCount++;
        }
      } else {
        break;
      }
    }
    
    this.pos = startPos; // reset

    // Calculate size based on instruction and operands
    if (mnem === 'LD') {
      if (operandCount === 2) {
        if (has16Bit) return 3; // LD dd,nn or LD (nn),r
        if (hasImmediate && hasRegister) return 2; // LD r,n (8-bit immediate)
        if (hasRegister && hasIndirect) return 1; // LD (HL),r or LD r,(HL)
        if (hasRegister && !hasImmediate) return 1; // LD r,r
        if (hasImmediate && hasIndirect) return 2; // LD (HL),n
        return 2; // Default estimate
      }
      return 2;
    }
    
    if (['ADD', 'ADC', 'SUB', 'SBC', 'AND', 'OR', 'XOR', 'CP'].includes(mnem)) {
      if (hasImmediate) return 2; // ALU A,n
      return 1; // ALU A,r
    }
    
    if (mnem === 'ADD' && operandCount === 2 && hasRegister) {
      return 1; // ADD HL,ss
    }
    
    if (['INC', 'DEC'].includes(mnem)) {
      if (hasRegister && !hasIndirect) {
        // Check if 16-bit register
        return 1; // Both 8-bit and 16-bit INC/DEC are 1 byte
      }
      if (hasIndirect) return 1; // INC (HL), DEC (HL)
      return 1;
    }
    
    if (['PUSH', 'POP'].includes(mnem)) {
      return 1;
    }
    
    if (mnem === 'RET' && operandCount > 0) {
      return 1; // RET cc
    }
    
    if (mnem === 'RST') {
      return 1;
    }
    
    if (['BIT', 'SET', 'RES', 'RLC', 'RRC', 'RL', 'RR', 'SLA', 'SRA', 'SLL', 'SRL'].includes(mnem)) {
      return 2; // CB-prefixed
    }
    
    if (['IN', 'OUT'].includes(mnem)) {
      return 2; // IN A,(n), OUT (n),A
    }
    
    // Default estimates
    if (has16Bit) return 3;
    if (hasImmediate) return 2;
    return 1;
  }

  defineSymbol(name, address, type = 'LABEL') {
    if (this.symbolTable[name] && type !== 'DEFL') {
      this.warnings.push({
        message: `Symbol ${name} redefined`,
        line: this.currentLine()
      });
    }
    this.symbolTable[name] = { address, type };
  }

  consume(expectedType) {
    if (this.check(expectedType)) {
      return this.advance();
    }
    throw new Error(`Expected ${expectedType}, got ${this.peek()?.type}`);
  }

  synchronize() {
    // Skip to next line
    while (!this.isAtEnd() && !this.check(TOKEN.NEWLINE)) {
      this.advance();
    }
    if (this.check(TOKEN.NEWLINE)) {
      this.advance();
    }
  }

  skipToNewline() {
    while (!this.isAtEnd() && !this.check(TOKEN.NEWLINE)) {
      this.advance();
    }
    if (this.check(TOKEN.NEWLINE)) {
      this.advance();
    }
  }

  peek() { return this.tokens[this.pos]; }
  advance() { return this.tokens[this.pos++]; }
  isAtEnd() { return this.pos >= this.tokens.length || this.peek()?.type === TOKEN.EOF; }
  check(type) { return this.peek()?.type === type; }
  checkNext(type) { return this.tokens[this.pos + 1]?.type === type; }
  currentLine() { return this.peek()?.line ?? this.tokens[this.pos - 1]?.line ?? 1; }
}




================================================
FILE: src/examples/programs.js
================================================
export const EXAMPLE_PROGRAMS = [
  {
    id: 'minimal',
    name: 'Minimal Program (NOP and HALT)',
    description: 'Simplest valid program. Tests basic instruction encoding.',
    source: `; minimal.asm - Simplest valid program
; Expected bytes: 00 76
; Expected size: 2 bytes

        .ORG    $4200

START:  NOP             ; Do nothing (opcode $00)
        HALT            ; Stop CPU (opcode $76)

        .END`,
    expectedBytes: [0x00, 0x76],
    expectedSymbols: { START: 0x4200 }
  },
  {
    id: 'add2plus2',
    name: 'Add 2+2',
    description: 'Basic arithmetic: 2 + 2 = 4',
    source: `; add2plus2.asm - Basic arithmetic: 2 + 2 = 4
; Tests: LD r,n / ADD A,r / LD (nn),A
; Expected size: 10 bytes

        .ORG    $4200

START:  LD      A, 2        ; A = 2          (3E 02)
        LD      B, 2        ; B = 2          (06 02)
        ADD     A, B        ; A = A + B = 4  (80)
        LD      (RESULT), A ; Store at RESULT (32 09 42)
        HALT                ; Stop           (76)

RESULT: .DB     0           ; Reserve 1 byte for result

        .END`,
    expectedBytes: [0x3E, 0x02, 0x06, 0x02, 0x80, 0x32, 0x09, 0x42, 0x76, 0x00],
    expectedSymbols: { START: 0x4200, RESULT: 0x4209 }
  },
  {
    id: 'fillscreen',
    name: 'Fill Screen with Solid Blocks',
    description: 'Fills the entire TRS-80 Model III screen with the solid block character ($BF)',
    source: `; fillscreen.asm - Fill screen with solid blocks (white)
; TRS-80 Model III video RAM: $3C00-$3FFF (1024 bytes, 64 cols x 16 rows)
; Character $BF = solid block (all 6 pixels lit in 2x3 cell)
; Tests: LD rr,nn / LD (HL),n / INC rr / DEC rr / OR / JR
; Expected size: 18 bytes

        .ORG    $4200

VRAM    .EQU    $3C00       ; Video RAM start address
VSIZE   .EQU    1024        ; Screen size in bytes

START:  LD      HL, VRAM    ; HL points to video RAM    (21 00 3C)
        LD      BC, VSIZE   ; BC = byte counter         (01 00 04)

FILL:   LD      (HL), $BF   ; Write solid block char    (36 BF)
        INC     HL          ; Next screen position      (23)
        DEC     BC          ; Decrement counter         (0B)
        LD      A, B        ; Check if BC = 0           (78)
        OR      C           ; A = B OR C                (B1)
        JR      NZ, FILL    ; Loop if not zero          (20 F8)
        HALT                ; Done                      (76)

        .END`,
    expectedBytes: [0x21, 0x00, 0x3C, 0x01, 0x00, 0x04, 0x36, 0xBF, 0x23, 0x0B, 0x78, 0xB1, 0x20, 0xF8, 0x76],
    expectedSymbols: { START: 0x4200, FILL: 0x4206, VRAM: 0x3C00, VSIZE: 0x0400 }
  },
  {
    id: 'clearscreen',
    name: 'Clear Screen (Spaces)',
    description: 'Clears screen to spaces using LDIR block transfer',
    source: `; clearscreen.asm - Clear screen using LDIR block transfer
; Tests: LD rr,nn / LD (HL),n / LDIR / HALT
; Expected size: 15 bytes

        .ORG    $4200

VRAM    .EQU    $3C00       ; Model III video RAM start
VSIZE   .EQU    1024        ; Model III screen size (64√ó16)

START:  LD      HL, VRAM    ; Source address            (21 00 3C)
        LD      (HL), $20   ; Put space at first byte   (36 20)
        LD      DE, VRAM+1  ; Dest = source + 1         (11 01 3C)
        LD      BC, VSIZE-1 ; Count = 1023              (01 FF 03)
        LDIR                ; Block copy                (ED B0)
        HALT                ;                           (76)

        .END`,
    expectedBytes: [0x21, 0x00, 0x3C, 0x36, 0x20, 0x11, 0x01, 0x3C, 0x01, 0xFF, 0x03, 0xED, 0xB0, 0x76],
    expectedSymbols: { START: 0x4200, VRAM: 0x3C00, VSIZE: 0x0400 }
  },
  {
    id: 'sierpinski',
    name: 'Sierpinski Triangle Pattern',
    description: 'Generates a Sierpinski triangle fractal pattern using bitwise AND',
    source: `; sierpinski.asm - Sierpinski triangle fractal pattern
; TRS-80 Model III: 64 cols √ó 16 rows video display
; Algorithm: if (X AND Y) == 0, plot solid block, else space
; Runs forever, continuously redrawing
; Tests: Complex loops, conditionals, coordinate math
; Expected size: 28 bytes

        .ORG    $4200

VRAM    .EQU    $3C00       ; Model III video RAM start
COLS    .EQU    64          ; Model III screen width
ROWS    .EQU    16          ; Model III screen height
BLOCK   .EQU    $BF         ; Solid block character
SPACE   .EQU    $20         ; Space character

START:  LD      HL, VRAM    ; Screen pointer            (21 00 3C)
        LD      D, 0        ; D = Y coordinate (row)    (16 00)

YLOOP:  LD      E, 0        ; E = X coordinate (col)    (1E 00)

XLOOP:  LD      A, E        ; A = X                     (7B)
        AND     D           ; A = X AND Y               (A2)
        JR      NZ, EMPTY   ; If != 0, use space        (20 04)
        LD      A, BLOCK    ; Solid block               (3E BF)
        JR      PLOT        ; Go write it               (18 02)
EMPTY:  LD      A, SPACE    ; Space character           (3E 20)
PLOT:   LD      (HL), A     ; Write to screen           (77)
        INC     HL          ; Next screen address       (23)
        INC     E           ; X++                       (1C)
        LD      A, E        ;                           (7B)
        CP      COLS        ; Reached end of row?       (FE 40)
        JR      NZ, XLOOP   ; No, continue row          (20 EE)

        INC     D           ; Y++ (next row)            (14)
        LD      A, D        ;                           (7A)
        CP      ROWS        ; Reached end of screen?    (FE 10)
        JR      NZ, YLOOP   ; No, continue              (20 E4)

        JR      START       ; Loop forever              (18 DC)

        .END`,
    expectedBytes: [0x21, 0x00, 0x3C, 0x16, 0x00, 0x1E, 0x00, 0x7B, 0xA2, 0x20, 0x05, 0x3E, 0xBF, 0x18, 0x04, 0x3E, 0x20, 0x77, 0x23, 0x1C, 0x7B, 0xFE, 0x40, 0x20, 0xEE, 0x14, 0x7A, 0xFE, 0x10, 0x20, 0xE6, 0x18, 0xDF],
    expectedSymbols: { BLOCK: 0xbf, COLS: 0x40, EMPTY: 0x4210, PLOT: 0x4213, ROWS: 0x10, SPACE: 0x20, START: 0x4200, VRAM: 0x3c00, XLOOP: 0x4207, YLOOP: 0x4205 }
  },
  {
    id: 'checkerboard',
    name: 'Scrolling Checkerboard Animation',
    description: 'Creates an animated checkerboard that shifts each frame',
    source: `; checkerboard.asm - Animated scrolling checkerboard
; TRS-80 Model III: 64 cols √ó 16 rows video display
; Alternates pattern each frame for animation effect
; Tests: XOR, frame counting, nested loops
; Expected size: 35 bytes

        .ORG    $4200

VRAM    .EQU    $3C00       ; Model III video RAM
COLS    .EQU    64          ; Model III screen width
ROWS    .EQU    16          ; Model III screen height
BLOCK   .EQU    $BF
SPACE   .EQU    $20

START:  LD      C, 0        ; C = frame counter (offset) (0E 00)

FRAME:  LD      HL, VRAM    ; Screen pointer            (21 00 3C)
        LD      D, 0        ; D = Y                     (16 00)

YLOOP:  LD      E, 0        ; E = X                     (1E 00)

XLOOP:  LD      A, E        ; A = X                     (7B)
        XOR     D           ; A = X XOR Y               (AA)
        XOR     C           ; A = (X XOR Y) XOR frame   (A9)
        AND     1           ; Check bit 0               (E6 01)
        JR      Z, DARK     ; If 0, use space           (28 04)
        LD      A, BLOCK    ; Solid block               (3E BF)
        JR      PLOT        ;                           (18 02)
DARK:   LD      A, SPACE    ; Space                     (3E 20)
PLOT:   LD      (HL), A     ; Write to screen           (77)
        INC     HL          ;                           (23)
        INC     E           ; X++                       (1C)
        LD      A, E        ;                           (7B)
        CP      COLS        ;                           (FE 40)
        JR      NZ, XLOOP   ;                           (20 EC)

        INC     D           ; Y++                       (14)
        LD      A, D        ;                           (7A)
        CP      ROWS        ;                           (FE 10)
        JR      NZ, YLOOP   ;                           (20 E2)

        INC     C           ; Next frame                (0C)
        JR      FRAME       ; Loop forever              (18 D8)

        .END`,
    expectedBytes: [0x0E, 0x00, 0x21, 0x00, 0x3C, 0x16, 0x00, 0x1E, 0x00, 0x7B, 0xAA, 0xA9, 0xE6, 0x01, 0x28, 0x05, 0x3E, 0xBF, 0x18, 0x04, 0x3E, 0x20, 0x77, 0x23, 0x1C, 0x7B, 0xFE, 0x40, 0x20, 0xEB, 0x14, 0x7A, 0xFE, 0x10, 0x20, 0xE3, 0x0C, 0x18, 0xDB],
    expectedSymbols: { BLOCK: 0xbf, COLS: 0x40, DARK: 0x4215, FRAME: 0x4202, PLOT: 0x4218, ROWS: 0x10, SPACE: 0x20, START: 0x4200, VRAM: 0x3c00, XLOOP: 0x4209, YLOOP: 0x4207 }
  },
  {
    id: 'datatest',
    name: 'Data Definition Test',
    description: 'Tests .DB and .DW directives, string definitions, and label references',
    source: `; datatest.asm - Test data definition directives
; Tests: .DB, .DW, .EQU, string data, label math
; Expected size: 32 bytes (approx)

        .ORG    $4200

OFFSET  .EQU    $10         ; Constant definition

START:  LD      HL, MESSAGE ; Load address of string    (21 xx xx)
        LD      A, (DATA1)  ; Load first data byte      (3A xx xx)
        LD      BC, (PTR1)  ; Load 16-bit value         (ED 4B xx xx)
        HALT                ;                           (76)

; Data section
MESSAGE:
        .DB     "HELLO", 0  ; Null-terminated string
DATA1:  .DB     $42         ; Single byte
DATA2:  .DB     1, 2, 3, 4  ; Multiple bytes
PTR1:   .DW     $1234       ; 16-bit word (little-endian: 34 12)
PTR2:   .DW     START        ; Address of START label
TABLE:  .DW     $0000, $FFFF, $1234  ; Multiple words

        .END`,
    expectedBytes: null, // Variable size, will be validated by test suite
    expectedSymbols: { DATA1: 0x420f, DATA2: 0x4210, MESSAGE: 0x420a, OFFSET: 0x10, PTR1: 0x4215, PTR2: 0x4217, START: 0x4200, TABLE: 0x4219 }
  },
  {
    id: 'conditions',
    name: 'Conditional Jumps Test',
    description: 'Exercises all condition codes (Z, NZ, C, NC, etc.)',
    source: `; conditions.asm - Test all conditional jumps
; Tests: JP cc, JR cc, CALL cc, RET cc
; Expected size: ~45 bytes

        .ORG    $4200

START:  LD      A, 0        ; Set A = 0, Zero flag set  (3E 00)
        JP      Z, TEST1    ; Jump if zero              (CA xx xx)
        HALT                ; Should not reach here     (76)

TEST1:  LD      A, 1        ; A = 1, Zero flag clear    (3E 01)
        JP      NZ, TEST2   ; Jump if not zero          (C2 xx xx)
        HALT                ;                           (76)

TEST2:  LD      A, $FF      ; A = 255                   (3E FF)
        ADD     A, 1        ; A = 0, Carry flag set     (C6 01)
        JP      C, TEST3    ; Jump if carry             (DA xx xx)
        HALT                ;                           (76)

TEST3:  LD      A, 1        ;                           (3E 01)
        AND     A           ; Clear carry flag          (A7)
        JP      NC, TEST4   ; Jump if no carry          (D2 xx xx)
        HALT                ;                           (76)

TEST4:  JR      Z, FAIL     ; Should not jump (NZ)      (28 xx)
        JR      NZ, TEST5   ; Should jump               (20 xx)
FAIL:   HALT                ;                           (76)

TEST5:  LD      A, $80      ; Test sign flag            (3E 80)
        AND     A           ; Set flags                 (A7)
        JP      M, TEST6    ; Jump if minus (negative)  (FA xx xx)
        HALT                ;                           (76)

TEST6:  LD      A, $01      ; Positive number           (3E 01)
        AND     A           ;                           (A7)
        JP      P, DONE     ; Jump if plus (positive)   (F2 xx xx)
        HALT                ;                           (76)

DONE:   HALT                ; All tests passed!         (76)

        .END`,
    expectedBytes: null, // Variable due to relative jumps
    expectedSymbols: { DONE: 0x422e, FAIL: 0x421f, START: 0x4200, TEST1: 0x4206, TEST2: 0x420c, TEST3: 0x4214, TEST4: 0x421b, TEST5: 0x4220, TEST6: 0x4227 }
  },
  {
    id: 'subroutine',
    name: 'Subroutine Test (CALL/RET)',
    description: 'Tests CALL and RET instructions, stack operations',
    source: `; subroutine.asm - Test CALL and RET
; Tests: CALL nn, RET, PUSH, POP, stack pointer
; Expected size: ~25 bytes

        .ORG    $4200

STACK   .EQU    $7FFF       ; Top of RAM for stack

START:  LD      SP, STACK   ; Initialize stack pointer  (31 FF 7F)
        LD      A, 5        ; A = 5                     (3E 05)
        CALL    DOUBLE      ; Call subroutine           (CD xx xx)
        ; A should now be 10
        LD      (RESULT), A ; Store result              (32 xx xx)
        HALT                ;                           (76)

; Subroutine: doubles the value in A
DOUBLE: PUSH    BC          ; Save BC                   (C5)
        LD      B, A        ; B = A                     (47)
        ADD     A, B        ; A = A + B = 2*A           (80)
        POP     BC          ; Restore BC                (C1)
        RET                 ; Return                    (C9)

RESULT: .DB     0           ; Storage for result

        .END`,
    expectedBytes: null, // Variable due to CALL address
    expectedSymbols: { DOUBLE: 0x420c, RESULT: 0x4211, STACK: 0x7fff, START: 0x4200 }
  },
  {
    id: 'keyboard',
    name: 'Keyboard Scan (I/O Test)',
    description: 'Tests IN and OUT instructions for TRS-80 Model III keyboard scanning',
    source: `; keyboard.asm - Basic keyboard scan
; TRS-80 Model III keyboard is memory-mapped at $3800-$3BFF
; Tests: IN, OUT, memory-mapped I/O concepts
; Expected size: ~20 bytes

        .ORG    $4200

KBBASE  .EQU    $3800       ; Keyboard base address
VRAM    .EQU    $3C00       ; Video RAM

START:  LD      HL, KBBASE  ; Point to keyboard matrix  (21 00 38)

SCAN:   LD      A, (HL)     ; Read keyboard row         (7E)
        CPL                 ; Invert (pressed = 1)      (2F)
        AND     A           ; Any key pressed?          (A7)
        JR      Z, NOKEY    ; No, skip                  (28 06)

        ; Key detected - display raw value
        LD      (VRAM), A   ; Show on screen            (32 00 3C)
        JR      SCAN        ; Keep scanning             (18 F3)

NOKEY:  LD      A, $20      ; Space (no key)            (3E 20)
        LD      (VRAM), A   ;                           (32 00 3C)
        JR      SCAN        ; Keep scanning             (18 EB)

        .END`,
    expectedBytes: null, // Variable due to relative jumps
    expectedSymbols: { KBBASE: 0x3800, NOKEY: 0x420d, SCAN: 0x4203, START: 0x4200, VRAM: 0x3c00 }
  },
  {
    id: 'bittest',
    name: 'Bit Manipulation Test',
    description: 'Tests BIT, SET, RES instructions',
    source: `; bittest.asm - Test bit manipulation instructions
; Tests: BIT b,r / SET b,r / RES b,r
; Expected size: ~30 bytes

        .ORG    $4200

START:  LD      A, 0        ; Start with all bits clear (3E 00)

        SET     0, A        ; Set bit 0: A = %00000001  (CB C7)
        SET     7, A        ; Set bit 7: A = %10000001  (CB FF)

        BIT     0, A        ; Test bit 0 (should be set, Z=0)  (CB 47)
        JR      Z, FAIL     ; Fail if zero flag set     (28 xx)

        BIT     1, A        ; Test bit 1 (should be clear, Z=1) (CB 4F)
        JR      NZ, FAIL    ; Fail if zero flag clear   (20 xx)

        RES     0, A        ; Clear bit 0: A = %10000000 (CB 87)

        BIT     0, A        ; Test bit 0 (should be clear) (CB 47)
        JR      NZ, FAIL    ; Fail if set               (20 xx)

        LD      (RESULT), A ; Store final value ($80)   (32 xx xx)
        LD      A, $01      ; Success code              (3E 01)
        JR      DONE        ;                           (18 xx)

FAIL:   LD      A, $00      ; Failure code              (3E 00)

DONE:   LD      (STATUS), A ;                           (32 xx xx)
        HALT                ;                           (76)

RESULT: .DB     0
STATUS: .DB     0

        .END`,
    expectedBytes: null, // Variable due to relative jumps
    expectedSymbols: { DONE: 0x421d, FAIL: 0x421b, RESULT: 0x4221, START: 0x4200, STATUS: 0x4222 }
  },
  {
    id: 'rotate',
    name: 'Rotate and Shift Test',
    description: 'Tests rotation and shift instructions',
    source: `; rotate.asm - Test rotate and shift instructions
; Tests: RLCA, RRCA, RLA, RRA, RLC, RRC, RL, RR, SLA, SRA, SRL
; Expected size: ~35 bytes

        .ORG    $4200

START:  LD      A, 1        ; A = 1                    (3E 01)

        RLCA                ; Rotate left: A = 2        (07)
        RLCA                ; Rotate left: A = 4        (07)
        LD      B, A        ; Save in B (B = 4)         (47)

        RRCA                ; Rotate right: A = 2        (0F)
        RRCA                ; Rotate right: A = 1        (0F)
        LD      C, A        ; Save in C (C = 1)         (4F)

        LD      A, $80      ; A = 128                  (3E 80)
        SRL     A           ; Shift right logical: A = 64 (CB 3F)
        SRL     A           ; A = 32                    (CB 3F)
        LD      D, A        ; Save in D (D = 32)        (57)

        LD      A, 1        ;                          (3E 01)
        SLA     A           ; Shift left: A = 2         (CB 27)
        SLA     A           ; A = 4                     (CB 27)
        SLA     A           ; A = 8                     (CB 27)
        LD      E, A        ; Save in E (E = 8)         (5F)

        HALT                ;                           (76)

        .END`,
    expectedBytes: [0x3E, 0x01, 0x07, 0x07, 0x47, 0x0F, 0x0F, 0x4F, 0x3E, 0x80, 0xCB, 0x3F, 0xCB, 0x3F, 0x57, 0x3E, 0x01, 0xCB, 0x27, 0xCB, 0x27, 0xCB, 0x27, 0x5F, 0x76],
    expectedSymbols: { START: 0x4200 }
  },
  {
    id: 'math16',
    name: '16-bit Arithmetic',
    description: 'Tests 16-bit operations: ADD HL, INC/DEC pairs',
    source: `; math16.asm - 16-bit arithmetic operations
; Tests: ADD HL,rr / INC rr / DEC rr / LD (nn),HL
; Expected size: ~25 bytes

        .ORG    $4200

START:  LD      HL, $1000   ; HL = $1000                (21 00 10)
        LD      BC, $0234   ; BC = $0234                (01 34 02)
        ADD     HL, BC      ; HL = $1234                (09)

        LD      DE, $0001   ; DE = 1                    (11 01 00)
        ADD     HL, DE      ; HL = $1235                (19)

        INC     HL          ; HL = $1236                (23)
        INC     HL          ; HL = $1237                (23)
        DEC     HL          ; HL = $1236                (2B)

        LD      (RESULT), HL ; Store result             (22 xx xx)
        HALT                ;                           (76)

RESULT: .DW     0           ; 16-bit storage

        .END`,
    expectedBytes: [0x21, 0x00, 0x10, 0x01, 0x34, 0x02, 0x09, 0x11, 0x01, 0x00, 0x19, 0x23, 0x23, 0x2B, 0x22, 0x11, 0x42, 0x76, 0x00, 0x00],
    expectedSymbols: { RESULT: 0x4211, START: 0x4200 }
  },
  {
    id: 'blockcopy',
    name: 'Block Memory Copy',
    description: 'Tests LDIR block transfer instruction',
    source: `; blockcopy.asm - Memory block copy using LDIR
; Copies SOURCE data to DEST using block transfer
; Tests: LDIR, block operations
; Expected size: ~25 bytes

        .ORG    $4200

START:  LD      HL, SOURCE  ; Source address            (21 xx xx)
        LD      DE, DEST    ; Destination address       (11 xx xx)
        LD      BC, SRCLEN  ; Byte count                (01 xx xx)
        LDIR                ; Block copy                (ED B0)
        HALT                ;                           (76)

SOURCE: .DB     "HELLO WORLD!", 0
SRCLEN  .EQU    $ - SOURCE  ; Calculate length automatically

DEST:   .DB     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

        .END`,
    expectedBytes: null, // Variable size
    expectedSymbols: { DEST: 0x4219, SOURCE: 0x420c, SRCLEN: 0xd, START: 0x4200 }
  },
  {
    id: 'expressions',
    name: 'Expression Evaluation Test',
    description: 'Tests the expression evaluator with various arithmetic',
    source: `; expressions.asm - Test expression evaluation
; Tests: +, -, *, /, $, parentheses, label arithmetic
; Expected size: varies

        .ORG    $4200

BASE    .EQU    $1000
OFFSET  .EQU    $0100
COMBO   .EQU    BASE + OFFSET       ; = $1100
DIFF    .EQU    BASE - $0800        ; = $0800
MULT    .EQU    16 * 4              ; = 64
DIV     .EQU    256 / 8             ; = 32

START:  LD      HL, BASE + OFFSET   ; HL = $1100        (21 00 11)
        LD      DE, COMBO           ; DE = $1100        (11 00 11)
        LD      BC, MULT + DIV      ; BC = 96 ($60)     (01 60 00)
        LD      A, ($ + 5)          ; Load from 5 bytes ahead

        ; Test current address ($) usage
HERE:   LD      HL, HERE            ; Should equal current address
        LD      DE, $ - START       ; Offset from START

        HALT                        ;                   (76)

        .END`,
    expectedBytes: null, // Variable due to $ usage
    expectedSymbols: { BASE: 0x1000, COMBO: 0x1100, DIFF: 0x800, DIV: 0x20, HERE: 0x420a, MULT: 0x40, OFFSET: 0x100, START: 0x4200 }
  },
  {
    id: 'multiply',
    name: 'Simple Multiply (3 √ó 4)',
    description: 'Multiplies two numbers using repeated addition',
    source: `; multiply.asm - Multiply 3 √ó 4 = 12 using repeated addition
; Tests: Loops, ADD, DEC, conditional jumps
; Expected size: ~18 bytes

        .ORG    $4200

START:  LD      A, 0        ; A = result (0)              (3E 00)
        LD      B, 3        ; B = multiplier (3)          (06 03)
        LD      C, 4        ; C = multiplicand (4)       (0E 04)

LOOP:   ADD     A, C        ; A = A + C                  (81)
        DEC     B           ; B--                         (05)
        JR      NZ, LOOP    ; Loop while B != 0           (20 FB)
        LD      (RESULT), A ; Store result (12)           (32 0A 42)
        HALT                ;                             (76)

RESULT: .DB     0

        .END`,
    expectedBytes: [0x3E, 0x00, 0x06, 0x03, 0x0E, 0x04, 0x81, 0x05, 0x20, 0xFC, 0x32, 0x0E, 0x42, 0x76, 0x00],
    expectedSymbols: { LOOP: 0x4206, RESULT: 0x420E, START: 0x4200 }
  },
  {
    id: 'strlen',
    name: 'String Length Calculation',
    description: 'Calculates the length of a null-terminated string',
    source: `; strlen.asm - Calculate string length
; Tests: String traversal, null checking, INC, CP
; Expected size: ~20 bytes

        .ORG    $4200

START:  LD      HL, STRING  ; Point to string              (21 0A 42)
        LD      B, 0        ; B = length counter          (06 00)

LOOP:   LD      A, (HL)     ; Load character              (7E)
        CP      0           ; Check for null terminator   (FE 00)
        JR      Z, DONE     ; Done if null                (28 04)
        INC     B           ; Increment length             (04)
        INC     HL          ; Next character              (23)
        JR      LOOP        ; Continue                    (18 F7)

DONE:   LD      A, B        ; A = length                  (78)
        LD      (LENGTH), A ; Store result                (32 19 42)
        HALT                ;                             (76)

STRING: .DB     "HELLO", 0
LENGTH: .DB     0

        .END`,
    expectedBytes: [0x21, 0x13, 0x42, 0x06, 0x00, 0x7E, 0xFE, 0x00, 0x28, 0x04, 0x04, 0x23, 0x18, 0xF7, 0x78, 0x32, 0x19, 0x42, 0x76, 0x48, 0x45, 0x4C, 0x4C, 0x4F, 0x00, 0x00],
    expectedSymbols: { DONE: 0x420E, LENGTH: 0x4219, LOOP: 0x4205, START: 0x4200, STRING: 0x4213 }
  },
  {
    id: 'lookup',
    name: 'Lookup Table',
    description: 'Uses a lookup table to convert numbers to characters',
    source: `; lookup.asm - Lookup table example
; Tests: Table indexing, indirect addressing, LD A,(HL)
; Expected size: ~22 bytes

        .ORG    $4200

START:  LD      A, 3        ; A = index (3)              (3E 03)
        LD      HL, TABLE   ; HL = table address          (21 0A 42)
        LD      D, 0        ; DE = A                      (16 00)
        LD      E, A        ;                             (5F)
        ADD     HL, DE      ; HL = TABLE + A               (19)
        LD      A, (HL)     ; A = TABLE[A]                 (7E)
        LD      (RESULT), A ; Store result                (32 11 42)
        HALT                ;                             (76)

TABLE:  .DB     '0', '1', '2', '3', '4', '5'
RESULT: .DB     0

        .END`,
    expectedBytes: [0x3E, 0x03, 0x21, 0x0E, 0x42, 0x16, 0x00, 0x5F, 0x19, 0x7E, 0x32, 0x14, 0x42, 0x76, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x00],
    expectedSymbols: { RESULT: 0x4214, START: 0x4200, TABLE: 0x420E }
  },
  {
    id: 'daa',
    name: 'Decimal Adjust (DAA)',
    description: 'Tests the DAA instruction for BCD arithmetic',
    source: `; daa.asm - Decimal Adjust Accumulator
; Tests: DAA instruction, BCD arithmetic
; Expected size: ~15 bytes

        .ORG    $4200

START:  LD      A, $19      ; A = 19 (BCD)                (3E 19)
        ADD     A, $07      ; A = 19 + 7 = 20 (needs adjust) (C6 07)
        DAA                 ; Adjust to BCD: A = 26       (27)
        LD      (RESULT), A ; Store result                (32 0C 42)
        LD      A, $45      ; A = 45 (BCD)                (3E 45)
        ADD     A, $38      ; A = 45 + 38 = 7D (needs adjust) (C6 38)
        DAA                 ; Adjust to BCD: A = 83       (27)
        LD      (SUM), A    ; Store sum                   (32 0D 42)
        HALT                ;                             (76)

RESULT: .DB     0
SUM:    .DB     0

        .END`,
    expectedBytes: [0x3E, 0x19, 0xC6, 0x07, 0x27, 0x32, 0x11, 0x42, 0x3E, 0x45, 0xC6, 0x38, 0x27, 0x32, 0x12, 0x42, 0x76, 0x00, 0x00],
    expectedSymbols: { RESULT: 0x4211, START: 0x4200, SUM: 0x4212 }
  },
  {
    id: 'negate',
    name: 'Negate and Complement',
    description: 'Tests NEG and CPL instructions',
    source: `; negate.asm - Negate and complement operations
; Tests: NEG, CPL, SCF, CCF
; Expected size: ~20 bytes

        .ORG    $4200

START:  LD      A, 5        ; A = 5                       (3E 05)
        NEG                 ; A = -5 = 251 (two's complement) (ED 44)
        LD      (NEG1), A   ; Store -5                    (32 0E 42)
        LD      A, $AA      ; A = 10101010                (3E AA)
        CPL                 ; A = 01010101 = $55          (2F)
        LD      (COMP), A   ; Store complement            (32 0F 42)
        SCF                 ; Set carry flag              (37)
        CCF                 ; Complement carry flag       (3F)
        HALT                ;                             (76)

NEG1:   .DB     0
COMP:   .DB     0

        .END`,
    expectedBytes: [0x3E, 0x05, 0xED, 0x44, 0x32, 0x10, 0x42, 0x3E, 0xAA, 0x2F, 0x32, 0x11, 0x42, 0x37, 0x3F, 0x76, 0x00, 0x00],
    expectedSymbols: { COMP: 0x4211, NEG1: 0x4210, START: 0x4200 }
  },
  {
    id: 'stackops',
    name: 'Stack Operations',
    description: 'Advanced stack manipulation with multiple registers',
    source: `; stackops.asm - Advanced stack operations
; Tests: PUSH, POP with multiple register pairs
; Expected size: ~18 bytes

        .ORG    $4200

STACK   .EQU    $7FFF

START:  LD      SP, STACK   ; Initialize stack            (31 FF 7F)
        LD      HL, $1234   ; HL = $1234                  (21 34 12)
        LD      DE, $5678   ; DE = $5678                  (11 78 56)
        PUSH    HL          ; Push HL                     (E5)
        PUSH    DE          ; Push DE                     (D5)
        POP     BC          ; Pop to BC (should be DE)    (C1)
        POP     HL          ; Pop to HL (should be original HL) (E1)
        LD      (SAVED), HL ; Store popped value          (22 12 42)
        HALT                ;                             (76)

SAVED:  .DW     0

        .END`,
    expectedBytes: [0x31, 0xFF, 0x7F, 0x21, 0x34, 0x12, 0x11, 0x78, 0x56, 0xE5, 0xD5, 0xC1, 0xE1, 0x22, 0x11, 0x42, 0x76, 0x00, 0x00],
    expectedSymbols: { SAVED: 0x4211, STACK: 0x7FFF, START: 0x4200 }
  },
  {
    id: 'portio',
    name: 'Port I/O Operations',
    description: 'Tests IN and OUT instructions with specific port numbers',
    source: `; portio.asm - Port I/O operations
; Tests: IN A,(n), OUT (n),A
; Expected size: ~15 bytes

        .ORG    $4200

PORT1   .EQU    $F8         ; TRS-80 port
PORT2   .EQU    $EC

START:  IN      A, (PORT1)  ; Read from port $F8          (DB F8)
        LD      B, A        ; Save in B                   (47)
        IN      A, (PORT2)  ; Read from port $EC          (DB EC)
        ADD     A, B        ; Add both values             (80)
        OUT     (PORT1), A  ; Write to port $F8            (D3 F8)
        LD      (RESULT), A ; Store result                (32 0C 42)
        HALT                ;                             (76)

RESULT: .DB     0

        .END`,
    expectedBytes: [0xDB, 0xF8, 0x47, 0xDB, 0xEC, 0x80, 0xD3, 0xF8, 0x32, 0x0C, 0x42, 0x76, 0x00],
    expectedSymbols: { PORT1: 0xF8, PORT2: 0xEC, RESULT: 0x420C, START: 0x4200 }
  },
  {
    id: 'restart',
    name: 'Restart Instruction (RST)',
    description: 'Tests RST instructions for interrupt-like behavior',
    source: `; restart.asm - Restart instruction test
; Tests: RST n (restart to vector addresses)
; Expected size: ~10 bytes

        .ORG    $4200

START:  LD      A, $42      ; A = $42                     (3E 42)
        RST     0           ; Restart to $0000            (C7)
        HALT                ; Should not reach here       (76)

SAVED:  .DB     0

        .END`,
    expectedBytes: [0x3E, 0x42, 0xC7, 0x76, 0x00],
    expectedSymbols: { SAVED: 0x4204, START: 0x4200 }
  },
  {
    id: 'exchange',
    name: 'Register Exchange (EXX)',
    description: 'Tests EXX instruction for alternate register set swapping',
    source: `; exchange.asm - Register exchange operations
; Tests: EXX (exchange alternate register sets)
; Expected size: ~20 bytes

        .ORG    $4200

START:  LD      BC, $1234   ; BC = $1234                  (01 34 12)
        LD      DE, $5678   ; DE = $5678                  (11 78 56)
        LD      HL, $9ABC   ; HL = $9ABC                  (21 BC 9A)
        EXX                 ; Exchange with alternate set (D9)
        LD      BC, $0000   ; BC' = $0000                 (01 00 00)
        LD      DE, $0000   ; DE' = $0000                 (11 00 00)
        LD      HL, $0000   ; HL' = $0000                 (21 00 00)
        EXX                 ; Exchange back                (D9)
        LD      (RESULT), HL ; Store HL                   (22 11 42)
        HALT                ;                             (76)

RESULT: .DW     0

        .END`,
    expectedBytes: [0x01, 0x34, 0x12, 0x11, 0x78, 0x56, 0x21, 0xBC, 0x9A, 0xD9, 0x01, 0x00, 0x00, 0x11, 0x00, 0x00, 0x21, 0x00, 0x00, 0xD9, 0x22, 0x15, 0x42, 0x76, 0x00, 0x00],
    expectedSymbols: { RESULT: 0x4215, START: 0x4200 }
  },
  {
    id: 'divide',
    name: 'Simple Divide (12 √∑ 3)',
    description: 'Divides using repeated subtraction',
    source: `; divide.asm - Divide 12 √∑ 3 = 4 using repeated subtraction
; Tests: Loops, SUB, conditional jumps, counters
; Expected size: ~20 bytes

        .ORG    $4200

START:  LD      A, 12       ; A = dividend (12)          (3E 0C)
        LD      B, 3        ; B = divisor (3)             (06 03)
        LD      C, 0        ; C = quotient (0)            (0E 00)

LOOP:   SUB     B           ; A = A - B                  (90)
        JR      C, DONE     ; Done if A < 0 (carry set)   (38 04)
        INC     C           ; Increment quotient          (0C)
        JR      LOOP        ; Continue                    (18 F9)

DONE:   LD      A, C        ; A = quotient (4)           (79)
        LD      (RESULT), A ; Store result                (32 0E 42)
        HALT                ;                             (76)

RESULT: .DB     0

        .END`,
    expectedBytes: [0x3E, 0x0C, 0x06, 0x03, 0x0E, 0x00, 0x90, 0x38, 0x03, 0x0C, 0x18, 0xFA, 0x79, 0x32, 0x11, 0x42, 0x76, 0x00],
    expectedSymbols: { DONE: 0x420C, LOOP: 0x4206, RESULT: 0x4211, START: 0x4200 }
  },
  {
    id: 'compare',
    name: 'Compare Operations',
    description: 'Tests CP instruction with various comparisons',
    source: `; compare.asm - Compare operations
; Tests: CP instruction, flag setting, conditional logic
; Expected size: ~22 bytes

        .ORG    $4200

START:  LD      A, 10       ; A = 10                      (3E 0A)
        CP      5           ; Compare A with 5            (FE 05)
        JR      C, LESS     ; Jump if A < 5               (38 04)
        JR      Z, EQUAL    ; Jump if A == 5              (28 04)
        LD      B, 1        ; A > 5                       (06 01)
        JR      DONE        ;                             (18 06)
LESS:   LD      B, 0        ; A < 5                      (06 00)
        JR      DONE        ;                             (18 02)
EQUAL:  LD      B, 2        ; A == 5                     (06 02)
DONE:   LD      A, B        ; A = result                 (78)
        LD      (RESULT), A ; Store (should be 1)         (32 14 42)
        HALT                ;                             (76)

RESULT: .DB     0

        .END`,
    expectedBytes: [0x3E, 0x0A, 0xFE, 0x05, 0x38, 0x06, 0x28, 0x08, 0x06, 0x01, 0x18, 0x06, 0x06, 0x00, 0x18, 0x02, 0x06, 0x02, 0x78, 0x32, 0x17, 0x42, 0x76, 0x00],
    expectedSymbols: { DONE: 0x4212, EQUAL: 0x4210, LESS: 0x420C, RESULT: 0x4217, START: 0x4200 }
  },
  {
    id: 'poker',
    name: 'Poker Hand Analyzer',
    description: 'Analyzes poker hands using bitwise operations. Detects Royal Flush, Flush, and other patterns.',
    source: `; poker.asm - Poker hand analyzer using bitwise operations
; Input: Hand encoded as bytes (5 cards: suit in upper 4 bits, value in lower 4 bits)
; Output: Hand rank (1=Royal Flush, 2=Flush, 10=High Card)
; Tests: Bitwise operations (AND, OR, SLA), pattern matching, loops
; Expected size: ~60 bytes

        .ORG    $4200

; Card encoding: suit in upper 4 bits, value in lower 4 bits
; Suits: 0=spades, 1=hearts, 2=diamonds, 3=clubs
; Values: A=14, K=13, Q=12, J=11, 10=10, 9-2=9-2
; Example: As = 0x0E (suit 0, value 14), Ks = 0x0D, Qs = 0x0C, Js = 0x0B, 10s = 0x0A

HAND:   .DB     $0E, $0D, $0C, $0B, $0A  ; Royal Flush: As Ks Qs Js 10s
RESULT: .DB     0                         ; Hand rank output

START:  LD      HL, HAND            ; Point to hand              (21 05 42)
        LD      B, 0                ; B = suit mask              (06 00)
        LD      C, 0                ; C = value mask              (0E 00)
        LD      D, 5                ; D = card counter            (16 05)

LOOP:   LD      A, (HL)             ; Load card                  (7E)
        LD      E, A                ; Save card                  (5F)
        AND     $F0                 ; Mask suit bits             (E6 F0)
        OR      B                   ; OR into suit mask          (B0)
        LD      B, A                ; Update suit mask           (47)
        LD      A, E                ; Restore card               (7B)
        AND     $0F                 ; Mask value bits            (E6 0F)
        OR      C                   ; OR into value mask         (B1)
        LD      C, A                ; Update value mask          (4F)
        INC     HL                  ; Next card                   (23)
        DEC     D                   ; Decrement counter          (15)
        JR      NZ, LOOP            ; Continue if more cards     (20 F3)

        ; Check for Royal Flush: A-K-Q-J-10 all same suit
        LD      A, B                ; Get suit mask               (78)
        AND     $F0                 ; Check if all same suit      (E6 F0)
        CP      $00                 ; All spades?                 (FE 00)
        JR      NZ, NOT_ROYAL       ; No, check other patterns    (20 0A)
        
        ; Check values: should have A(14), K(13), Q(12), J(11), 10(10)
        LD      A, C                ; Get value mask              (79)
        CP      $3E                 ; Check for pattern (simplified) (FE 3E)
        JR      Z, ROYAL_FLUSH       ; Royal flush found!          (28 04)
        
NOT_ROYAL:
        ; Check for Flush: all same suit (any 5 cards)
        LD      A, B                ; Get suit mask               (78)
        AND     $F0                 ; Mask suit bits              (E6 F0)
        CP      $00                 ; All same suit?              (FE 00)
        JR      Z, FLUSH            ; Yes, it's a flush           (28 04)
        JR      HIGH_CARD           ; No, high card               (18 04)

ROYAL_FLUSH:
        LD      A, 1                ; Royal Flush = 1             (3E 01)
        LD      (RESULT), A         ; Store result                (32 06 42)
        HALT                        ;                             (76)

FLUSH:  LD      A, 2                ; Flush = 2                   (3E 02)
        LD      (RESULT), A         ; Store result                (32 06 42)
        HALT                        ;                             (76)

HIGH_CARD:
        LD      A, 10               ; High Card = 10              (3E 0A)
        LD      (RESULT), A         ; Store result                (32 06 42)
        HALT                        ;                             (76)

        .END`,
    expectedBytes: [0x0E, 0x0D, 0x0C, 0x0B, 0x0A, 0x00, 0x21, 0x00, 0x42, 0x06, 0x00, 0x0E, 0x00, 0x16, 0x05, 0x7E, 0x5F, 0xE6, 0xF0, 0xB0, 0x47, 0x7B, 0xE6, 0x0F, 0xB1, 0x4F, 0x23, 0x15, 0x20, 0xF1, 0x78, 0xE6, 0xF0, 0xFE, 0x00, 0x20, 0x05, 0x79, 0xFE, 0x3E, 0x28, 0x09, 0x78, 0xE6, 0xF0, 0xFE, 0x00, 0x28, 0x08, 0x18, 0x0C, 0x3E, 0x01, 0x32, 0x05, 0x42, 0x76, 0x3E, 0x02, 0x32, 0x05, 0x42, 0x76, 0x3E, 0x0A, 0x32, 0x05, 0x42, 0x76],
    expectedSymbols: { FLUSH: 16953, HAND: 16896, HIGH_CARD: 16959, LOOP: 16911, NOT_ROYAL: 16938, RESULT: 16901, ROYAL_FLUSH: 16947, START: 16902 }
  }
];




================================================
FILE: src/tests/test-suite.js
================================================
import { Z80Assembler } from '../assembler.js';
import { EXAMPLE_PROGRAMS } from '../examples/programs.js';

/**
 * Compare two byte arrays
 */
function compareBytes(actual, expected) {
  if (actual.length !== expected.length) {
    return {
      match: false,
      message: `Length mismatch: expected ${expected.length}, got ${actual.length}`
    };
  }

  for (let i = 0; i < actual.length; i++) {
    if (actual[i] !== expected[i]) {
      return {
        match: false,
        message: `Byte mismatch at offset ${i}: expected 0x${expected[i].toString(16).padStart(2, '0')}, got 0x${actual[i].toString(16).padStart(2, '0')}`
      };
    }
  }

  return { match: true };
}

/**
 * Compare symbol tables
 */
function compareSymbols(actual, expected) {
  const missing = [];
  const wrong = [];

  for (const [name, expectedAddr] of Object.entries(expected)) {
    const symbol = actual[name];
    if (!symbol) {
      missing.push(name);
    } else if (symbol.address !== expectedAddr) {
      wrong.push(`${name}: expected 0x${expectedAddr.toString(16)}, got 0x${symbol.address.toString(16)}`);
    }
  }

  if (missing.length > 0 || wrong.length > 0) {
    return {
      match: false,
      message: [
        missing.length > 0 ? `Missing symbols: ${missing.join(', ')}` : '',
        wrong.length > 0 ? `Wrong addresses: ${wrong.join('; ')}` : ''
      ].filter(m => m).join(' ')
    };
  }

  return { match: true };
}

/**
 * Test a single example program
 */
function testExample(example, assembler) {
  const startTime = performance.now();
  const result = assembler.assemble(example.source);
  const endTime = performance.now();
  const duration = (endTime - startTime).toFixed(2);

  const testResult = {
    id: example.id,
    name: example.name,
    passed: true,
    errors: [],
    warnings: [],
    duration,
    bytesGenerated: result.bytes ? result.bytes.length : 0,
    bytesExpected: example.expectedBytes ? example.expectedBytes.length : 0,
    symbolsGenerated: result.symbolTable ? Object.keys(result.symbolTable).length : 0,
    symbolsExpected: example.expectedSymbols ? Object.keys(example.expectedSymbols).length : 0,
    result
  };

  // Check for assembly errors
  if (!result.success || result.errors.length > 0) {
    testResult.passed = false;
    testResult.errors.push(`Assembly failed: ${result.errors.map(e => e.message).join('; ')}`);
    return testResult;
  }

  // Check bytecode if expected bytes are provided
  if (example.expectedBytes !== null && example.expectedBytes !== undefined) {
    const bytesMatch = compareBytes(Array.from(result.bytes), example.expectedBytes);
    if (!bytesMatch.match) {
      testResult.passed = false;
      testResult.errors.push(`Bytecode mismatch: ${bytesMatch.message}`);
      testResult.errors.push(`Expected: ${example.expectedBytes.map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ')}`);
      testResult.errors.push(`Got: ${Array.from(result.bytes).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ')}`);
    }
  }

  // Check symbols
  if (example.expectedSymbols) {
    const symbolsMatch = compareSymbols(result.symbolTable, example.expectedSymbols);
    if (!symbolsMatch.match) {
      testResult.passed = false;
      testResult.errors.push(`Symbol mismatch: ${symbolsMatch.message}`);
    }
  }

  // Collect warnings
  if (result.warnings.length > 0) {
    testResult.warnings = result.warnings.map(w => w.message);
  }

  return testResult;
}

/**
 * Run the complete test suite
 */
export function runTestSuite() {
  const assembler = new Z80Assembler();
  const results = [];

  console.log('Running Z80 Assembler Test Suite...\n');

  for (const example of EXAMPLE_PROGRAMS) {
    const testResult = testExample(example, assembler);
    results.push(testResult);

    const status = testResult.passed ? '‚úì PASS' : '‚úó FAIL';
    const statusColor = testResult.passed ? '\x1b[32m' : '\x1b[31m'; // Green or Red
    const resetColor = '\x1b[0m';
    
    console.log(`\n${statusColor}[${status}]${resetColor} ${testResult.name}`);
    console.log(`  ID: ${testResult.id}`);
    console.log(`  Description: ${example.description || 'N/A'}`);
    console.log(`  Duration: ${testResult.duration}ms`);
    console.log(`  Bytes: ${testResult.bytesGenerated}${testResult.bytesExpected ? ` (expected ${testResult.bytesExpected})` : ''}`);
    console.log(`  Symbols: ${testResult.symbolsGenerated}${testResult.symbolsExpected ? ` (expected ${testResult.symbolsExpected})` : ''}`);
    
    // Show first 16 bytes of generated code
    if (testResult.result.bytes && testResult.result.bytes.length > 0) {
      const preview = Array.from(testResult.result.bytes)
        .slice(0, 16)
        .map(b => b.toString(16).padStart(2, '0').toUpperCase())
        .join(' ');
      const more = testResult.result.bytes.length > 16 ? '...' : '';
      console.log(`  Bytecode: ${preview}${more}`);
    }
    
    // Show key symbols (up to 5)
    if (testResult.result.symbolTable && Object.keys(testResult.result.symbolTable).length > 0) {
      const symbols = Object.entries(testResult.result.symbolTable)
        .slice(0, 5)
        .map(([name, info]) => `${name}:0x${info.address.toString(16).toUpperCase()}`)
        .join(', ');
      const moreSyms = Object.keys(testResult.result.symbolTable).length > 5 ? '...' : '';
      console.log(`  Symbols: ${symbols}${moreSyms}`);
    }
    
    if (!testResult.passed) {
      console.log(`  ${statusColor}Errors:${resetColor}`);
      testResult.errors.forEach(err => console.log(`    ‚Ä¢ ${err}`));
    }
    if (testResult.warnings.length > 0) {
      console.log(`  \x1b[33mWarnings:\x1b[0m`);
      testResult.warnings.forEach(warn => console.log(`    ‚Ä¢ ${warn}`));
    }
  }

  // Summary
  const passed = results.filter(r => r.passed).length;
  const failed = results.filter(r => !r.passed).length;
  const total = results.length;
  const totalTime = results.reduce((sum, r) => sum + parseFloat(r.duration), 0).toFixed(2);
  const totalBytes = results.reduce((sum, r) => sum + r.bytesGenerated, 0);

  console.log('\n' + '='.repeat(70));
  console.log('                    TEST SUITE SUMMARY');
  console.log('='.repeat(70));
  
  const passColor = passed === total ? '\x1b[32m' : '\x1b[33m';
  const failColor = failed > 0 ? '\x1b[31m' : '\x1b[32m';
  const resetColor = '\x1b[0m';
  
  console.log(`  Total Tests:     ${total}`);
  console.log(`  ${passColor}Passed:${resetColor}          ${passed}`);
  console.log(`  ${failColor}Failed:${resetColor}          ${failed}`);
  console.log(`  Success Rate:    ${((passed/total)*100).toFixed(1)}%`);
  console.log(`  Total Time:      ${totalTime}ms`);
  console.log(`  Avg Time/Test:   ${(totalTime/total).toFixed(2)}ms`);
  console.log(`  Total Bytes:     ${totalBytes} (${(totalBytes/1024).toFixed(2)}KB)`);
  console.log('='.repeat(70));

  if (failed > 0) {
    console.log('\n' + failColor + 'FAILED TESTS:' + resetColor);
    results.filter(r => !r.passed).forEach(r => {
      console.log(`\n  ${failColor}‚úó${resetColor} ${r.name} (${r.id})`);
      r.errors.forEach(err => console.log(`    ${err}`));
    });
  } else {
    console.log(`\n${passColor}üéâ All tests passed!${resetColor}`);
  }

  return {
    total,
    passed,
    failed,
    results
  };
}

// If running in Node.js, execute tests
if (typeof window === 'undefined') {
  runTestSuite();
}




================================================
FILE: src/ui/examples.js
================================================
/**
 * @fileoverview Example program management for the UI
 * 
 * Handles loading and displaying the 15 pre-built example programs
 * in the UI dropdown selector. Examples include everything from
 * simple programs to complex TRS-80 Model III demonstrations.
 * 
 * @module ui/examples
 * @requires ../examples/programs
 */

import { EXAMPLE_PROGRAMS } from '../examples/programs.js';

/**
 * @typedef {Object} ExampleProgram
 * @property {string} id - Unique identifier for the example
 * @property {string} name - Display name of the example
 * @property {string} description - Brief description of what the example demonstrates
 * @property {string} source - Z80 assembly source code
 * @property {Array<number>} expectedBytes - Expected bytecode output
 * @property {Object<string, number>} expectedSymbols - Expected symbol table
 */

/**
 * Initializes the example programs dropdown selector
 * 
 * Populates a <select> element with all available example programs
 * and sets up an event listener to load the selected example.
 * 
 * The dropdown shows each example with format: "Name - Description"
 * When an example is selected, the onSelect callback is invoked with
 * the complete example object.
 * 
 * @param {HTMLSelectElement} selectElement - The dropdown <select> element to populate
 * @param {Function} onSelect - Callback function invoked when an example is selected
 * @param {ExampleProgram} onSelect.example - The selected example program object
 * 
 * @example
 * const dropdown = document.getElementById('exampleSelect');
 * initExamplesDropdown(dropdown, (example) => {
 *   console.log('Selected:', example.name);
 *   sourceEditor.value = example.source;
 * });
 */
export function initExamplesDropdown(selectElement, onSelect) {
  // Clear any existing options and add placeholder
  selectElement.innerHTML = '<option value="">Select an example program...</option>';
  
  // Populate dropdown with all 15 examples
  EXAMPLE_PROGRAMS.forEach(example => {
    const option = document.createElement('option');
    option.value = example.id;
    option.textContent = `${example.name} - ${example.description}`;
    selectElement.appendChild(option);
  });
  
  // Handle selection changes
  selectElement.addEventListener('change', (e) => {
    const selectedId = e.target.value;
    if (selectedId) {
      const example = getExampleById(selectedId);
      if (example && onSelect) {
        onSelect(example);
      }
    }
  });
}

/**
 * Retrieves an example program by its unique ID
 * 
 * Searches through all available examples and returns the one matching
 * the given ID, or undefined if not found.
 * 
 * @param {string} id - Unique identifier of the example (e.g., 'add2plus2', 'fillscreen')
 * @returns {ExampleProgram|undefined} The matching example program, or undefined if not found
 * 
 * @example
 * const example = getExampleById('add2plus2');
 * if (example) {
 *   console.log(example.source);  // Displays the assembly source
 * }
 */
export function getExampleById(id) {
  return EXAMPLE_PROGRAMS.find(ex => ex.id === id);
}

/**
 * Gets all available example programs
 * 
 * Returns the complete array of all 15 example programs.
 * Useful for iteration, testing, or programmatic access.
 * 
 * @returns {Array<ExampleProgram>} Array of all example programs
 * 
 * @example
 * const examples = getAllExamples();
 * console.log(`There are ${examples.length} example programs`);
 * examples.forEach(ex => console.log(`- ${ex.name}`));
 */
export function getAllExamples() {
  return EXAMPLE_PROGRAMS;
}




================================================
FILE: src/utils/formatter.js
================================================
/**
 * @fileoverview Output formatting utilities for Z80 assembler
 * 
 * Provides functions to format assembly output in TRS-80 Model III
 * DEBUG-style format, including memory dumps, symbol tables, and
 * error/warning messages.
 * 
 * @module utils/formatter
 */

/**
 * Formats bytecode as TRS-80 Model III DEBUG-style memory dump
 * 
 * Creates a hexadecimal memory dump with 16 bytes per line, showing
 * both hex values and ASCII representation. Mimics the output format
 * of the TRS-80 Model III DEBUG command for authenticity.
 * 
 * Format:
 * ```
 * ADDR  +0 +1 +2 +3 +4 +5 +6 +7  +8 +9 +A +B +C +D +E +F   ASCII
 * 4200  3E 05 76 -- -- -- -- --  -- -- -- -- -- -- -- --   >.v.............
 * ```
 * 
 * @param {Uint8Array} bytes - Machine code bytes to display
 * @param {number} startAddress - Origin address where code begins
 * @returns {string} Multi-line formatted hex dump with ASCII
 * 
 * @example
 * const bytes = new Uint8Array([0x3E, 0x05, 0x76]);
 * const dump = formatMemoryDump(bytes, 0x4200);
 * console.log(dump);
 * // Outputs TRS-80 style hex dump starting at $4200
 */
export function formatMemoryDump(bytes, startAddress) {
  const lines = [];
  
  // Header
  lines.push('ADDR  +0 +1 +2 +3 +4 +5 +6 +7  +8 +9 +A +B +C +D +E +F   ASCII');
  lines.push('----  -- -- -- -- -- -- -- --  -- -- -- -- -- -- -- --   ----------------');
  
  // Round start address down to 16-byte boundary
  const baseAddr = startAddress & 0xFFF0;
  const offset = startAddress - baseAddr;
  
  // Calculate total rows needed
  const totalBytes = offset + bytes.length;
  const rows = Math.ceil(totalBytes / 16);
  
  for (let row = 0; row < rows; row++) {
    const addr = baseAddr + (row * 16);
    let hexPart = '';
    let asciiPart = '';
    
    for (let col = 0; col < 16; col++) {
      const byteIndex = (row * 16) + col - offset;
      
      // Add spacing between byte 7 and 8
      if (col === 8) hexPart += ' ';
      
      if (byteIndex < 0 || byteIndex >= bytes.length) {
        // Outside our data range
        hexPart += '-- ';
        asciiPart += '.';
      } else {
        const byte = bytes[byteIndex];
        hexPart += byte.toString(16).toUpperCase().padStart(2, '0') + ' ';
        
        // ASCII: printable characters only (0x20-0x7E)
        if (byte >= 0x20 && byte <= 0x7E) {
          asciiPart += String.fromCharCode(byte);
        } else {
          asciiPart += '.';
        }
      }
    }
    
    const addrStr = addr.toString(16).toUpperCase().padStart(4, '0');
    lines.push(`${addrStr}  ${hexPart}  ${asciiPart}`);
  }
  
  return lines.join('\n');
}

/**
 * Formats symbol table for display
 * 
 * Creates a sorted table of all symbols (labels, constants) with their
 * addresses and types. Symbols are sorted by address in ascending order.
 * 
 * Format:
 * ```
 * LABEL          ADDR   TYPE
 * -------------- ----   -----
 * START          4200   LABEL
 * VRAM           3C00   EQU
 * RESULT         4209   LABEL
 * ```
 * 
 * @param {Object.<string, {address: number, type: string}>} symbolTable - Symbol table from assembler
 * @returns {string} Multi-line formatted symbol table
 * 
 * @example
 * const symbols = {
 *   START: { address: 0x4200, type: 'LABEL' },
 *   VRAM: { address: 0x3C00, type: 'EQU' }
 * };
 * console.log(formatSymbolTable(symbols));
 */
export function formatSymbolTable(symbolTable) {
  const lines = [];
  
  // Header
  lines.push('LABEL          ADDR   TYPE');
  lines.push('-------------- ----   -----');
  
  // Sort entries by address (ascending)
  const entries = Object.entries(symbolTable).sort((a, b) => {
    return a[1].address - b[1].address;
  });
  
  // Format each entry
  for (const [name, entry] of entries) {
    const addrStr = entry.address.toString(16).toUpperCase().padStart(4, '0');
    const paddedName = name.padEnd(14);
    lines.push(`${paddedName} ${addrStr}   ${entry.type}`);
  }
  
  return lines.join('\n');
}

/**
 * Formats errors for display
 * 
 * Converts error objects into human-readable error messages with
 * line and column information.
 * 
 * @param {Array<{message: string, line: number, column?: number}>} errors - Array of error objects
 * @returns {string} Formatted error messages, one per line
 * 
 * @example
 * const errors = [
 *   { message: 'Undefined symbol: LABEL', line: 5, column: 10 },
 *   { message: 'Invalid opcode', line: 7 }
 * ];
 * console.log(formatErrors(errors));
 * // Line 5, Col 10: Undefined symbol: LABEL
 * // Line 7: Invalid opcode
 */
export function formatErrors(errors) {
  if (errors.length === 0) return 'No errors.';
  
  return errors.map(err => {
    const loc = err.column ? `Line ${err.line}, Col ${err.column}` : `Line ${err.line}`;
    return `${loc}: ${err.message}`;
  }).join('\n');
}

/**
 * Formats warnings for display
 * 
 * Converts warning objects into human-readable warning messages with
 * line and column information. Similar to formatErrors but for warnings.
 * 
 * @param {Array<{message: string, line: number, column?: number}>} warnings - Array of warning objects
 * @returns {string} Formatted warning messages, one per line
 * 
 * @example
 * const warnings = [
 *   { message: 'Symbol redefined', line: 10, column: 1 }
 * ];
 * console.log(formatWarnings(warnings));
 * // Line 10, Col 1: Symbol redefined
 */
export function formatWarnings(warnings) {
  if (warnings.length === 0) return 'No warnings.';
  
  return warnings.map(warn => {
    const loc = warn.column ? `Line ${warn.line}, Col ${warn.column}` : `Line ${warn.line}`;
    return `${loc}: ${warn.message}`;
  }).join('\n');
}

/**
 * Formats byte array as space-separated hex string
 * 
 * Converts a byte array into a readable hexadecimal string with
 * spaces between each byte. Useful for displaying bytecode sequences.
 * 
 * @param {Uint8Array|Array<number>} bytes - Array of byte values (0-255)
 * @returns {string} Space-separated hex string (e.g., "3E 05 76")
 * 
 * @example
 * const bytes = new Uint8Array([0x3E, 0x05, 0x76]);
 * console.log(formatBytes(bytes));  // "3E 05 76"
 * 
 * @example
 * const instruction = [0xCD, 0x00, 0x42];
 * console.log(formatBytes(instruction));  // "CD 00 42"
 */
export function formatBytes(bytes) {
  return Array.from(bytes)
    .map(b => b.toString(16).toUpperCase().padStart(2, '0'))
    .join(' ');
}




================================================
FILE: styles/main.css
================================================
/* TRS-80 Model III Theme */
:root {
    --bg-primary: #001100;
    --bg-secondary: #002200;
    --fg-primary: #33FF33;
    --fg-secondary: #66FF66;
    --border-color: #00AA00;
    --error-color: #FF3333;
    --warning-color: #FFAA00;
    --panel-bg: #000800;
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Courier New', monospace;
    background-color: var(--bg-primary);
    color: var(--fg-primary);
    line-height: 1.6;
    padding: 20px;
}

.container {
    max-width: 1600px;
    margin: 0 auto;
}

header {
    text-align: center;
    margin-bottom: 20px;
    padding: 20px;
    background-color: var(--bg-secondary);
    border: 2px solid var(--border-color);
}

header h1 {
    font-size: 2em;
    text-shadow: 0 0 10px var(--fg-primary);
}

.toolbar {
    display: flex;
    gap: 10px;
    align-items: center;
    margin-bottom: 20px;
    padding: 10px;
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
}

.toolbar select {
    flex: 1;
    padding: 8px;
    background-color: var(--panel-bg);
    color: var(--fg-primary);
    border: 1px solid var(--border-color);
    font-family: inherit;
    font-size: 14px;
}

.toolbar select:focus {
    outline: 2px solid var(--fg-primary);
    outline-offset: 2px;
}

.toolbar button {
    padding: 8px 20px;
    background-color: var(--bg-secondary);
    color: var(--fg-primary);
    border: 2px solid var(--border-color);
    font-family: inherit;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.2s;
}

.toolbar button:hover {
    background-color: var(--border-color);
    box-shadow: 0 0 10px var(--fg-primary);
}

.toolbar button:active {
    transform: scale(0.98);
}

.status {
    padding: 8px 15px;
    border: 1px solid var(--border-color);
    font-size: 14px;
}

.status-info {
    color: var(--fg-primary);
}

.status-success {
    color: var(--fg-secondary);
    border-color: var(--fg-secondary);
}

.status-error {
    color: var(--error-color);
    border-color: var(--error-color);
}

.main-content {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    margin-bottom: 20px;
}

.secondary-content {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
}

.panel {
    background-color: var(--panel-bg);
    border: 2px solid var(--border-color);
    padding: 15px;
}

.panel h2 {
    margin-bottom: 10px;
    font-size: 1.2em;
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 5px;
}

.panel h3 {
    margin-top: 10px;
    margin-bottom: 5px;
    font-size: 1em;
    color: var(--fg-secondary);
}

.source-panel h2 {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.char-counter {
    font-size: 0.7em;
    font-weight: normal;
    color: var(--fg-secondary);
    margin-left: 10px;
}

.char-counter-warning {
    color: var(--warning-color);
}

.char-counter-danger {
    color: var(--error-color);
    font-weight: bold;
}

.source-panel textarea {
    width: 100%;
    height: 500px;
    background-color: var(--bg-primary);
    color: var(--fg-primary);
    border: 1px solid var(--border-color);
    padding: 10px;
    font-family: 'Courier New', monospace;
    font-size: 14px;
    resize: vertical;
    tab-size: 4;
}

.source-panel textarea:focus {
    outline: 2px solid var(--fg-primary);
    outline-offset: 2px;
}

.output-panel pre,
.symbols-panel pre {
    background-color: var(--bg-primary);
    padding: 10px;
    border: 1px solid var(--border-color);
    overflow-x: auto;
    font-size: 12px;
    line-height: 1.4;
    max-height: 500px;
    overflow-y: auto;
}

.errors-panel pre {
    background-color: var(--bg-primary);
    padding: 10px;
    border: 1px solid var(--border-color);
    overflow-x: auto;
    font-size: 12px;
    line-height: 1.4;
    max-height: 200px;
    overflow-y: auto;
}

.errors-section pre {
    color: var(--error-color);
}

.warnings-section pre {
    color: var(--warning-color);
}

/* Scrollbar styling */
pre::-webkit-scrollbar,
textarea::-webkit-scrollbar {
    width: 12px;
    height: 12px;
}

pre::-webkit-scrollbar-track,
textarea::-webkit-scrollbar-track {
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
}

pre::-webkit-scrollbar-thumb,
textarea::-webkit-scrollbar-thumb {
    background: var(--border-color);
    border: 2px solid var(--bg-primary);
}

pre::-webkit-scrollbar-thumb:hover,
textarea::-webkit-scrollbar-thumb:hover {
    background: var(--fg-primary);
}

/* Responsive design */
@media (max-width: 1200px) {
    .main-content,
    .secondary-content {
        grid-template-columns: 1fr;
    }
}

@media (max-width: 768px) {
    body {
        padding: 10px;
    }

    header h1 {
        font-size: 1.5em;
    }

    .toolbar {
        flex-direction: column;
    }

    .toolbar select,
    .toolbar button {
        width: 100%;
    }

    .source-panel textarea {
        height: 300px;
    }
}



